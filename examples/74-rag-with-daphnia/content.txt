================================================
File: README.md
================================================
# Extism Go SDK

This repo houses the Go SDK for integrating with the [Extism](https://extism.org/) runtime. Install this library into your host Go applications to run Extism plugins.

Join the [Extism Discord](https://extism.org/discord) and chat with us!

## Installation

Install via `go get`:

```
go get github.com/extism/go-sdk
```

## Reference Docs

You can find the reference docs at [https://pkg.go.dev/github.com/extism/go-sdk](https://pkg.go.dev/github.com/extism/go-sdk).

## Getting Started

This guide should walk you through some of the concepts in Extism and this Go library.

### Creating A Plug-in

The primary concept in Extism is the [plug-in](https://extism.org/docs/concepts/plug-in). You can think of a plug-in as a code module stored in a `.wasm` file.

Plug-in code can come from a file on disk, object storage or any number of places. Since you may not have one handy let's load a demo plug-in from the web. Let's
start by creating a main func and loading an Extism Plug-in:

```go
package main

import (
	"context"
	"fmt"
	"github.com/extism/go-sdk"
	"os"
)

func main() {
	manifest := extism.Manifest{
		Wasm: []extism.Wasm{
			extism.WasmUrl{
				Url: "https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm",
			},
		},
	}

	ctx := context.Background()
	config := extism.PluginConfig{}
	plugin, err := extism.NewPlugin(ctx, manifest, config, []extism.HostFunction{})

	if err != nil {
		fmt.Printf("Failed to initialize plugin: %v\n", err)
		os.Exit(1)
	}
}
```
> **Note**: See [the Manifest docs](https://pkg.go.dev/github.com/extism/go-sdk#Manifest) as it has a rich schema and a lot of options.

### Calling A Plug-in's Exports

This plug-in was written in Rust and it does one thing, it counts vowels in a string. As such, it exposes one "export" function: `count_vowels`. We can call exports using [extism.Plugin.Call](https://pkg.go.dev/github.com/extism/go-sdk#Plugin.Call).
Let's add that code to our main func:

```go
func main() {
    // ...

	data := []byte("Hello, World!")
	exit, out, err := plugin.Call("count_vowels", data)
	if err != nil {
		fmt.Println(err)
		os.Exit(int(exit))
	}

	response := string(out)
	fmt.Println(response)
    // => {"count": 3, "total": 3, "vowels": "aeiouAEIOU"}
}
```

Running this should print out the JSON vowel count report:

```bash
$ go run main.go
# => {"count":3,"total":3,"vowels":"aeiouAEIOU"}
```

All exports have a simple interface of optional bytes in, and optional bytes out. This plug-in happens to take a string and return a JSON encoded string with a report of results.

> **Note**: If you want to pass a custom `context.Context` when calling a plugin function, you can use the [extism.Plugin.CallWithContext](https://pkg.go.dev/github.com/extism/go-sdk#Plugin.CallWithContext) method instead.


### Plug-in State

Plug-ins may be stateful or stateless. Plug-ins can maintain state between calls by the use of variables. Our count vowels plug-in remembers the total number of vowels it's ever counted in the "total" key in the result. You can see this by making subsequent calls to the export:

```go
func main () {
    // ...

    exit, out, err := plugin.Call("count_vowels", []byte("Hello, World!"))
    if err != nil {
        fmt.Println(err)
        os.Exit(int(exit))
    }
    fmt.Println(string(out))
    // => {"count": 3, "total": 6, "vowels": "aeiouAEIOU"}

    exit, out, err = plugin.Call("count_vowels", []byte("Hello, World!"))
    if err != nil {
        fmt.Println(err)
        os.Exit(int(exit))
    }
    fmt.Println(string(out))
    // => {"count": 3, "total": 9, "vowels": "aeiouAEIOU"}
}

```

These variables will persist until this plug-in is freed or you initialize a new one.

### Configuration

Plug-ins may optionally take a configuration object. This is a static way to configure the plug-in. Our count-vowels plugin takes an optional configuration to change out which characters are considered vowels. Example:

```go
func main() {
    manifest := extism.Manifest{
        Wasm: []extism.Wasm{
            extism.WasmUrl{
                Url: "https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm",
            },
        },
        Config: map[string]string{
            "vowels": "aeiouyAEIOUY",
        },
    }

    ctx := context.Background()
    config := extism.PluginConfig{}

    plugin, err := extism.NewPlugin(ctx, manifest, config, []extism.HostFunction{})

    if err != nil {
        fmt.Printf("Failed to initialize plugin: %v\n", err)
        os.Exit(1)
    }

    exit, out, err := plugin.Call("count_vowels", []byte("Yellow, World!"))
    if err != nil {
        fmt.Println(err)
        os.Exit(int(exit))
    }

    fmt.Println(string(out))
    // => {"count": 4, "total": 4, "vowels": "aeiouAEIOUY"}
}
```

### Host Functions

Let's extend our count-vowels example a little bit: Instead of storing the `total` in an ephemeral plug-in var, let's store it in a persistent key-value store!

Wasm can't use our KV store on it's own. This is where [Host Functions](https://extism.org/docs/concepts/host-functions) come in.

[Host functions](https://extism.org/docs/concepts/host-functions) allow us to grant new capabilities to our plug-ins from our application. They are simply some Go functions you write which can be passed down and invoked from any language inside the plug-in.

Let's load the manifest like usual but load up this `count_vowels_kvstore` plug-in:

```go
manifest := extism.Manifest{
    Wasm: []extism.Wasm{
        extism.WasmUrl{
            Url: "https://github.com/extism/plugins/releases/latest/download/count_vowels_kvstore.wasm",
        },
    },
}
```

> *Note*: The source code for this is [here](https://github.com/extism/plugins/blob/main/count_vowels_kvstore/src/lib.rs) and is written in rust, but it could be written in any of our PDK languages.

Unlike our previous plug-in, this plug-in expects you to provide host functions that satisfy our its import interface for a KV store.

We want to expose two functions to our plugin, `kv_write(key string, value []bytes)` which writes a bytes value to a key and `kv_read(key string) []byte` which reads the bytes at the given `key`.
```go
// pretend this is Redis or something :)
kvStore := make(map[string][]byte)

kvRead := extism.NewHostFunctionWithStack(
    "kv_read",
    func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) {
        key, err := p.ReadString(stack[0])
        if err != nil {
            panic(err)
        }

        value, success := kvStore[key]
        if !success {
            value = []byte{0, 0, 0, 0}
        }

        stack[0], err = p.WriteBytes(value)
    },
    []ValueType{ValueTypePTR},
    []ValueType{ValueTypePTR},
)

kvWrite := extism.NewHostFunctionWithStack(
    "kv_write",
    func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) {
        key, err := p.ReadString(stack[0])
        if err != nil {
            panic(err)
        }

        value, err := p.ReadBytes(stack[1])
        if err != nil {
            panic(err)
        }

        kvStore[key] = value
    },
    []ValueType{ValueTypePTR, ValueTypePTR},
    []ValueType{},
)
```

> *Note*: In order to write host functions you should get familiar with the methods on the [extism.CurrentPlugin](https://pkg.go.dev/github.com/extism/go-sdk#CurrentPlugin) type. The `p` parameter is an instance of this type.

We need to pass these imports to the plug-in to create them. All imports of a plug-in must be satisfied for it to be initialized:

```go
plugin, err := extism.NewPlugin(ctx, manifest, config, []extism.HostFunction{kvRead, kvWrite});
```

Now we can invoke the event:

```go
exit, out, err := plugin.Call("count_vowels", []byte("Hello, World!"))
// => Read from key=count-vowels"
// => Writing value=3 from key=count-vowels"
// => {"count": 3, "total": 3, "vowels": "aeiouAEIOU"}

exit, out, err = plugin.Call("count_vowels", []byte("Hello, World!"))
// => Read from key=count-vowels"
// => Writing value=6 from key=count-vowels"
// => {"count": 3, "total": 6, "vowels": "aeiouAEIOU"}
```

### Enabling Compilation Cache
While Wazero (the underlying Wasm runtime) is very fast in initializing modules, you can make subsequent initializations even faster by enabling the compilation cache:

```go
ctx := context.Background()
cache := wazero.NewCompilationCache()
defer cache.Close(ctx)

manifest := Manifest{Wasm: []Wasm{WasmFile{Path: "wasm/noop.wasm"}}}

config := PluginConfig{
    EnableWasi:    true,
    ModuleConfig:  wazero.NewModuleConfig(),
    RuntimeConfig: wazero.NewRuntimeConfig().WithCompilationCache(cache),
}

_, err := NewPlugin(ctx, manifest, config, []HostFunction{})
```

### Integrate with Dylibso Observe SDK
Dylibso provides [observability SDKs](https://github.com/dylibso/observe-sdk) for WebAssembly (Wasm), enabling continuous monitoring of WebAssembly code as it executes within a runtime. It provides developers with the tools necessary to capture and emit telemetry data from Wasm code, including function execution and memory allocation traces, logs, and metrics.

While Observe SDK has adapters for many popular observability platforms, it also ships with an stdout adapter:

```
ctx := context.Background()

adapter := stdout.NewStdoutAdapter()
adapter.Start(ctx)

manifest := manifest("nested.c.instr.wasm")

config := PluginConfig{
    ModuleConfig:   wazero.NewModuleConfig().WithSysWalltime(),
    EnableWasi:     true,
    ObserveAdapter: adapter.AdapterBase,
}

plugin, err := NewPlugin(ctx, manifest, config, []HostFunction{})
if err != nil {
    panic(err)
}

meta := map[string]string{
    "http.url":         "https://example.com/my-endpoint",
    "http.status_code": "200",
    "http.client_ip":   "192.168.1.0",
}

plugin.TraceCtx.Metadata(meta)

_, _, _ = plugin.Call("_start", []byte("hello world"))
plugin.Close()
```

### Enable filesystem access

WASM plugins can read/write files outside the runtime. To do this we add `AllowedPaths` mapping of "HOST:PLUGIN" to the `extism.Manifest` of our plugin.

```go
package main

import (
	"context"
	"fmt"
	"os"

	extism "github.com/extism/go-sdk"
)

func main() {
	manifest := extism.Manifest{
		AllowedPaths: map[string]string{
			// Here we specifify a host directory data to be linked
			// to the /mnt directory inside the wasm runtime
			"data": "/mnt",
		},
		Wasm: []extism.Wasm{
			extism.WasmFile{
				Path: "fs_plugin.wasm",
			},
		},
	}

	ctx := context.Background()
	config := extism.PluginConfig{
		EnableWasi: true,
	}
	plugin, err := extism.NewPlugin(ctx, manifest, config, []extism.HostFunction{})

	if err != nil {
		fmt.Printf("Failed to initialize plugin: %v\n", err)
		os.Exit(1)
	}

	data := []byte("Hello world, this is written from within our wasm plugin.")
	exit, _, err := plugin.Call("write_file", data)
	if err != nil {
		fmt.Println(err)
		os.Exit(int(exit))
	}
}
```

> *Note*: In order for filesystem APIs to work the plugin needs to be compiled with WASI target. Source code for the plugin can be found [here](https://github.com/extism/go-pdk/blob/main/example/fs/main.go) and is written in Go, but it could be written in any of our PDK languages.

## Build example plugins

Since our [example plugins](./plugins/) are also written in Go, for compiling them we use [TinyGo](https://tinygo.org/):

```sh
cd plugins/config
tinygo build -target wasi -o ../wasm/config.wasm main.go
```


================================================
File: extism.go
================================================
package extism

import (
	"context"
	"crypto/sha256"
	_ "embed"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"math"
	"net/http"
	"os"
	"sync/atomic"
	"time"

	observe "github.com/dylibso/observe-sdk/go"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/sys"
)

type PluginCtxKey string
type InputOffsetKey string

//go:embed extism-runtime.wasm
var extismRuntimeWasm []byte

//go:embed extism-runtime.wasm.version
var extismRuntimeWasmVersion string

func RuntimeVersion() string {
	return extismRuntimeWasmVersion
}

// Runtime represents the Extism plugin's runtime environment, including the underlying Wazero runtime and modules.
type Runtime struct {
	Wazero wazero.Runtime
	Extism api.Module
	Env    api.Module
}

// PluginInstanceConfig contains configuration options for the Extism plugin.
type PluginInstanceConfig struct {
	// ModuleConfig allows the user to specify custom module configuration.
	//
	// NOTE: Module name and start functions are ignored as they are overridden by Extism, also if Manifest contains
	// non-empty AllowedPaths, then FS is also ignored. If EXTISM_ENABLE_WASI_OUTPUT is set, then stdout and stderr are
	// set to os.Stdout and os.Stderr respectively (ignoring user defined module config).
	ModuleConfig wazero.ModuleConfig
}

// HttpRequest represents an HTTP request to be made by the plugin.
type HttpRequest struct {
	Url     string
	Headers map[string]string
	Method  string
}

// LogLevel defines different log levels.
type LogLevel int32

const (
	logLevelUnset LogLevel = iota // unexporting this intentionally so its only ever the default
	LogLevelTrace
	LogLevelDebug
	LogLevelInfo
	LogLevelWarn
	LogLevelError

	LogLevelOff LogLevel = math.MaxInt32
)

func (l LogLevel) ExtismCompat() int32 {
	switch l {
	case LogLevelTrace:
		return 0
	case LogLevelDebug:
		return 1
	case LogLevelInfo:
		return 2
	case LogLevelWarn:
		return 3
	case LogLevelError:
		return 4
	default:
		return int32(LogLevelOff)
	}
}

func (l LogLevel) String() string {
	s := ""
	switch l {
	case LogLevelTrace:
		s = "TRACE"
	case LogLevelDebug:
		s = "DEBUG"
	case LogLevelInfo:
		s = "INFO"
	case LogLevelWarn:
		s = "WARN"
	case LogLevelError:
		s = "ERROR"
	default:
		s = "OFF"
	}
	return s
}

// Plugin is used to call WASM functions
type Plugin struct {
	close                []func(ctx context.Context) error
	extism               api.Module
	mainModule           api.Module
	modules              map[string]api.Module
	Timeout              time.Duration
	Config               map[string]string
	Var                  map[string][]byte
	AllowedHosts         []string
	AllowedPaths         map[string]string
	LastStatusCode       int
	LastResponseHeaders  map[string]string
	MaxHttpResponseBytes int64
	MaxVarBytes          int64
	log                  func(LogLevel, string)
	hasWasi              bool
	guestRuntime         guestRuntime
	Adapter              *observe.AdapterBase
	traceCtx             *observe.TraceCtx
}

func logStd(level LogLevel, message string) {
	log.Print(message)
}

func (p *Plugin) Module() *Module {
	return &Module{inner: p.mainModule}
}

// SetLogger sets a custom logging callback
func (p *Plugin) SetLogger(logger func(LogLevel, string)) {
	p.log = logger
}

func (p *Plugin) Log(level LogLevel, message string) {
	minimumLevel := LogLevel(pluginLogLevel.Load())

	// If the global log level hasn't been set, use LogLevelOff as default
	if minimumLevel == logLevelUnset {
		minimumLevel = LogLevelOff
	}

	if level >= minimumLevel {
		p.log(level, message)
	}
}

func (p *Plugin) Logf(level LogLevel, format string, args ...any) {
	message := fmt.Sprintf(format, args...)
	p.Log(level, message)
}

// Wasm is an interface that represents different ways of providing WebAssembly data.
type Wasm interface {
	ToWasmData(ctx context.Context) (WasmData, error)
}

// WasmData represents in-memory WebAssembly data, including its content, hash, and name.
type WasmData struct {
	Data []byte `json:"data"`
	Hash string `json:"hash,omitempty"`
	Name string `json:"name,omitempty"`
}

// WasmFile represents WebAssembly data that needs to be loaded from a file.
type WasmFile struct {
	Path string `json:"path"`
	Hash string `json:"hash,omitempty"`
	Name string `json:"name,omitempty"`
}

// WasmUrl represents WebAssembly data that needs to be fetched from a URL.
type WasmUrl struct {
	Url     string            `json:"url"`
	Hash    string            `json:"hash,omitempty"`
	Headers map[string]string `json:"headers,omitempty"`
	Name    string            `json:"name,omitempty"`
	Method  string            `json:"method,omitempty"`
}

type concreteWasm struct {
	Data    []byte            `json:"data,omitempty"`
	Path    string            `json:"path,omitempty"`
	Url     string            `json:"url,omitempty"`
	Headers map[string]string `json:"headers,omitempty"`
	Method  string            `json:"method,omitempty"`
	Hash    string            `json:"hash,omitempty"`
	Name    string            `json:"name,omitempty"`
}

func (d WasmData) ToWasmData(ctx context.Context) (WasmData, error) {
	return d, nil
}

func (f WasmFile) ToWasmData(ctx context.Context) (WasmData, error) {
	select {
	case <-ctx.Done():
		return WasmData{}, ctx.Err()
	default:
		data, err := os.ReadFile(f.Path)
		if err != nil {
			return WasmData{}, err
		}

		return WasmData{
			Data: data,
			Hash: f.Hash,
			Name: f.Name,
		}, nil
	}
}

func (u WasmUrl) ToWasmData(ctx context.Context) (WasmData, error) {
	client := http.DefaultClient

	req, err := http.NewRequestWithContext(ctx, u.Method, u.Url, nil)
	if err != nil {
		return WasmData{}, err
	}

	for key, value := range u.Headers {
		req.Header.Set(key, value)
	}

	resp, err := client.Do(req)
	if err != nil {
		return WasmData{}, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return WasmData{}, errors.New("failed to fetch Wasm data from URL")
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return WasmData{}, err
	}

	return WasmData{
		Data: data,
		Hash: u.Hash,
		Name: u.Name,
	}, nil
}

type ManifestMemory struct {
	MaxPages             uint32 `json:"max_pages,omitempty"`
	MaxHttpResponseBytes int64  `json:"max_http_response_bytes,omitempty"`
	MaxVarBytes          int64  `json:"max_var_bytes,omitempty"`
}

// Manifest represents the plugin's manifest, including Wasm modules and configuration.
// See https://extism.org/docs/concepts/manifest for schema.
type Manifest struct {
	Wasm         []Wasm            `json:"wasm"`
	Memory       *ManifestMemory   `json:"memory,omitempty"`
	Config       map[string]string `json:"config,omitempty"`
	AllowedHosts []string          `json:"allowed_hosts,omitempty"`
	AllowedPaths map[string]string `json:"allowed_paths,omitempty"`
	Timeout      uint64            `json:"timeout_ms,omitempty"`
}

type concreteManifest struct {
	Wasm   []concreteWasm `json:"wasm"`
	Memory *struct {
		MaxPages             uint32 `json:"max_pages,omitempty"`
		MaxHttpResponseBytes *int64 `json:"max_http_response_bytes,omitempty"`
		MaxVarBytes          *int64 `json:"max_var_bytes,omitempty"`
	} `json:"memory,omitempty"`
	Config       map[string]string `json:"config,omitempty"`
	AllowedHosts []string          `json:"allowed_hosts,omitempty"`
	AllowedPaths map[string]string `json:"allowed_paths,omitempty"`
	Timeout      uint64            `json:"timeout_ms,omitempty"`
}

func (m *Manifest) UnmarshalJSON(data []byte) error {
	tmp := concreteManifest{}
	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	m.Memory = &ManifestMemory{}
	if tmp.Memory != nil {
		m.Memory.MaxPages = tmp.Memory.MaxPages
		if tmp.Memory.MaxHttpResponseBytes != nil {
			m.Memory.MaxHttpResponseBytes = *tmp.Memory.MaxHttpResponseBytes
		} else {
			m.Memory.MaxHttpResponseBytes = -1
		}

		if tmp.Memory.MaxVarBytes != nil {
			m.Memory.MaxVarBytes = *tmp.Memory.MaxVarBytes
		} else {
			m.Memory.MaxVarBytes = -1
		}
	} else {
		m.Memory.MaxPages = 0
		m.Memory.MaxHttpResponseBytes = -1
		m.Memory.MaxVarBytes = -1
	}
	m.Config = tmp.Config
	m.AllowedHosts = tmp.AllowedHosts
	m.AllowedPaths = tmp.AllowedPaths
	m.Timeout = tmp.Timeout
	if m.Wasm == nil {
		m.Wasm = []Wasm{}
	}
	for _, w := range tmp.Wasm {
		if len(w.Data) > 0 {
			m.Wasm = append(m.Wasm, WasmData{Data: w.Data, Hash: w.Hash, Name: w.Name})
		} else if len(w.Path) > 0 {
			m.Wasm = append(m.Wasm, WasmFile{Path: w.Path, Hash: w.Hash, Name: w.Name})
		} else if len(w.Url) > 0 {
			m.Wasm = append(m.Wasm, WasmUrl{
				Url:     w.Url,
				Headers: w.Headers,
				Method:  w.Method,
				Hash:    w.Hash,
				Name:    w.Name,
			})
		} else {
			return errors.New("invalid Wasm entry")
		}
	}
	return nil
}

// Close closes the plugin by freeing the underlying resources.
func (p *Plugin) Close(ctx context.Context) error {
	return p.CloseWithContext(ctx)
}

// CloseWithContext closes the plugin by freeing the underlying resources.
func (p *Plugin) CloseWithContext(ctx context.Context) error {
	for _, fn := range p.close {
		if err := fn(ctx); err != nil {
			return err
		}
	}
	return nil
}

// add an atomic global to store the plugin runtime-wide log level
var pluginLogLevel = atomic.Int32{}

// SetPluginLogLevel sets the log level for the plugin
func SetLogLevel(level LogLevel) {
	pluginLogLevel.Store(int32(level))
}

// SetInput sets the input data for the plugin to be used in the next WebAssembly function call.
func (p *Plugin) SetInput(data []byte) (uint64, error) {
	return p.SetInputWithContext(context.Background(), data)
}

// SetInputWithContext sets the input data for the plugin to be used in the next WebAssembly function call.
func (p *Plugin) SetInputWithContext(ctx context.Context, data []byte) (uint64, error) {
	_, err := p.extism.ExportedFunction("reset").Call(ctx)
	if err != nil {
		fmt.Println(err)
		return 0, errors.New("reset")
	}

	ptr, err := p.extism.ExportedFunction("alloc").Call(ctx, uint64(len(data)))
	if err != nil {
		return 0, err
	}
	p.Memory().Write(uint32(ptr[0]), data)
	p.extism.ExportedFunction("input_set").Call(ctx, ptr[0], uint64(len(data)))
	return ptr[0], nil
}

// GetOutput retrieves the output data from the last WebAssembly function call.
func (p *Plugin) GetOutput() ([]byte, error) {
	return p.GetOutputWithContext(context.Background())
}

// GetOutputWithContext retrieves the output data from the last WebAssembly function call.
func (p *Plugin) GetOutputWithContext(ctx context.Context) ([]byte, error) {
	outputOffs, err := p.extism.ExportedFunction("output_offset").Call(ctx)
	if err != nil {
		return []byte{}, err
	}

	outputLen, err := p.extism.ExportedFunction("output_length").Call(ctx)
	if err != nil {
		return []byte{}, err
	}
	mem, _ := p.Memory().Read(uint32(outputOffs[0]), uint32(outputLen[0]))

	// Make sure output is copied, because `Read` returns a write-through view
	buffer := make([]byte, len(mem))
	copy(buffer, mem)

	return buffer, nil
}

// Memory returns the plugin's WebAssembly memory interface.
func (p *Plugin) Memory() api.Memory {
	return p.extism.ExportedMemory("memory")
}

// GetError retrieves the error message from the last WebAssembly function call, if any.
func (p *Plugin) GetError() string {
	return p.GetErrorWithContext(context.Background())
}

// GetErrorWithContext retrieves the error message from the last WebAssembly function call.
func (p *Plugin) GetErrorWithContext(ctx context.Context) string {
	errOffs, err := p.extism.ExportedFunction("error_get").Call(ctx)
	if err != nil {
		return ""
	}

	if errOffs[0] == 0 {
		return ""
	}

	errLen, err := p.extism.ExportedFunction("length").Call(ctx, errOffs[0])
	if err != nil {
		return ""
	}

	mem, _ := p.Memory().Read(uint32(errOffs[0]), uint32(errLen[0]))
	return string(mem)
}

// FunctionExists returns true when the named function is present in the plugin's main Module
func (p *Plugin) FunctionExists(name string) bool {
	return p.mainModule.ExportedFunction(name) != nil
}

// Call a function by name with the given input, returning the output
func (p *Plugin) Call(name string, data []byte) (uint32, []byte, error) {
	return p.CallWithContext(context.Background(), name, data)
}

// Call a function by name with the given input and context, returning the output
func (p *Plugin) CallWithContext(ctx context.Context, name string, data []byte) (uint32, []byte, error) {
	ctx = context.WithValue(ctx, PluginCtxKey("extism"), p.extism)
	if p.Timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, p.Timeout)
		defer cancel()
	}

	ctx = context.WithValue(ctx, PluginCtxKey("plugin"), p)

	intputOffset, err := p.SetInput(data)
	if err != nil {
		return 1, []byte{}, err
	}

	ctx = context.WithValue(ctx, InputOffsetKey("inputOffset"), intputOffset)

	var f = p.mainModule.ExportedFunction(name)

	if f == nil {
		return 1, []byte{}, fmt.Errorf("unknown function: %s", name)
	} else if n := len(f.Definition().ResultTypes()); n > 1 {
		return 1, []byte{}, fmt.Errorf("function %s has %v results, expected 0 or 1", name, n)
	}

	var isStart = name == "_start" || name == "_initialize"
	if p.guestRuntime.init != nil && !isStart && !p.guestRuntime.initialized {
		err := p.guestRuntime.init(ctx)
		if err != nil {
			return 1, []byte{}, fmt.Errorf("failed to initialize runtime: %v", err)
		}
		p.guestRuntime.initialized = true
	}

	p.Logf(LogLevelDebug, "Calling function : %v", name)

	res, err := f.Call(ctx)

	if p.traceCtx != nil {
		defer p.traceCtx.Finish()
	}

	// Try to extact WASI exit code
	if exitErr, ok := err.(*sys.ExitError); ok {
		exitCode := exitErr.ExitCode()

		if exitCode == 0 {
			// It's possible for the function to return 0 as an error code, even
			// if the module is closed.
			if p.mainModule.IsClosed() {
				return 0, nil, fmt.Errorf("module is closed")
			}
			err = nil
		}

		if len(res) == 0 {
			res = []uint64{api.EncodeU32(exitCode)}
		}
	}

	var rc uint32
	if len(res) == 0 {
		// As long as there is no error, we assume the call has succeeded
		if err == nil {
			rc = 0
		} else {
			rc = 1
		}
	} else {
		rc = api.DecodeU32(res[0])
	}

	if err != nil {
		return rc, []byte{}, err
	}

	var returnErr error = nil
	errMsg := p.GetErrorWithContext(ctx)
	if errMsg != "" {
		returnErr = errors.New(errMsg)
	}

	output, err := p.GetOutputWithContext(ctx)
	if err != nil {
		e := fmt.Errorf("failed to get output: %v", err)
		if returnErr != nil {
			return rc, []byte{}, errors.Join(returnErr, e)
		} else {
			return rc, []byte{}, e
		}
	}

	return rc, output, returnErr
}

func calculateHash(data []byte) string {
	hasher := sha256.New()
	hasher.Write(data)
	return hex.EncodeToString(hasher.Sum(nil))
}


================================================
File: extism_test.go
================================================
package extism

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"sync"
	"testing"
	"time"

	observe "github.com/dylibso/observe-sdk/go"
	"github.com/dylibso/observe-sdk/go/adapter/stdout"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/experimental"
	"github.com/tetratelabs/wazero/experimental/logging"
	"github.com/tetratelabs/wazero/sys"
)

func TestWasmUrl(t *testing.T) {
	url := "https://raw.githubusercontent.com/extism/extism/main/wasm/code.wasm"
	wasm := WasmUrl{
		Url:  url,
		Name: "code",
		Hash: "0c1779c48f56f94b3e3624d76f55e38215870c59ccb3d41f6ba8b2bc22f218f5",
	}

	manifest := Manifest{
		Wasm:         []Wasm{wasm},
		Config:       make(map[string]string),
		AllowedHosts: []string{},
		AllowedPaths: make(map[string]string),
	}

	_, ok := pluginInstance(t, manifest)
	assert.True(t, ok, "Plugin must be succussfuly created")
}

func TestHashMismatch(t *testing.T) {
	wasm := WasmFile{
		Path: "wasm/alloc.wasm",
		Name: "code",
		Hash: "------",
	}

	manifest := Manifest{
		Wasm:         []Wasm{wasm},
		Config:       make(map[string]string),
		AllowedHosts: []string{},
		AllowedPaths: make(map[string]string),
	}

	ctx := context.Background()
	//config := wasiPluginConfig()

	_, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi: true,
	}, nil)

	assert.NotNil(t, err, "Plugin must fail")
}

func TestFunctionExsits(t *testing.T) {
	manifest := manifest("alloc.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		assert.True(t, plugin.FunctionExists("run_test"))
		assert.False(t, plugin.FunctionExists("i_dont_exist"))
	}
}

func TestFailOnUnknownFunction(t *testing.T) {
	manifest := manifest("alloc.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		_, _, err := plugin.Call("i_dont_exist", []byte{})
		assert.NotNil(t, err, "Call to unknwon function must fail")
	}
}

func TestCallFunction(t *testing.T) {
	manifest := manifest("count_vowels.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		cases := map[string]int{
			"hello world": 3,
			"aaaaaa":      6,
			"":            0,
			"bbbbbbb":     0,
		}

		for input, expected := range cases {
			exit, output, err := plugin.Call("count_vowels", []byte(input))

			if assertCall(t, err, exit) {
				var actual map[string]int
				json.Unmarshal(output, &actual)

				assert.Equal(t, expected, actual["count"], "'%s' contains %v vowels", input, expected)
			}
		}
	}
}

func TestCallFunctionMultipleInstances(t *testing.T) {
	ctx := context.Background()
	manifest := manifest("alloc.wasm")
	plugin := plugin(t, manifest)

	var wg sync.WaitGroup
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()

			instance, err := plugin.Instance(ctx, PluginInstanceConfig{})
			require.NoError(t, err)
			defer func() {
				require.NoError(t, instance.Close(ctx))
			}()

			exit, _, err := instance.Call("run_test", []byte{})
			assertCall(t, err, exit)
		}()
	}
	wg.Wait()
}

func TestClosePlugin(t *testing.T) {
	manifest := manifest("alloc.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {

		exit, _, err := plugin.Call("run_test", []byte{})
		assertCall(t, err, exit)

		err = plugin.Close(context.Background())
		if err != nil {
			t.Errorf("Close must not return an error: %v", err)
		}

		_, _, err = plugin.Call("run_test", []byte{})
		assert.NotNil(t, err, "Call must fail after plugin was closed")
	}
}

func TestAlloc(t *testing.T) {
	manifest := manifest("alloc.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, _, err := plugin.Call("run_test", []byte{})

		assertCall(t, err, exit)
	}
}

func TestConfig(t *testing.T) {

	params := map[string]string{
		"hello": `{"config": "hello"}`,
		"":      `{"config": "<unset by host>"}`,
	}

	for k, v := range params {
		manifest := manifest("config.wasm")

		if k != "" {
			manifest.Config["thing"] = k
		}

		if plugin, ok := pluginInstance(t, manifest); ok {
			defer plugin.Close(context.Background())

			exit, output, err := plugin.Call("run_test", []byte{})

			if assertCall(t, err, exit) {
				actual := string(output)
				expected := v

				assert.Equal(t, expected, actual)
			}
		}
	}
}

func TestFail(t *testing.T) {
	manifest := manifest("fail.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, _, err := plugin.Call("run_test", []byte{})

		assert.Equal(t, uint32(1), exit, "Exit code must be 1")
		assert.Equal(t, "Some error message", err.Error())
	}
}

func TestHello(t *testing.T) {
	manifest := manifest("hello.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := "Hello, world!"

			assert.Equal(t, expected, actual)
		}
	}
}

func TestExit(t *testing.T) {
	cases := map[string]uint32{
		"-1":  0xffffffff, // NOTE: wazero doesn't support negative exit codes
		"500": 500,
		"abc": 1,
		"":    2,
	}

	for config, expected := range cases {
		manifest := manifest("exit.wasm")

		if plugin, ok := pluginInstance(t, manifest); ok {
			defer plugin.Close(context.Background())

			if config != "" {
				plugin.Config["code"] = config
			}

			actual, _, err := plugin.Call("_start", []byte{})

			if actual != 0 {
				assert.NotNil(t, err, fmt.Sprintf("err can't be nil. config: %v", config))
			}

			assert.Equal(t, expected, actual, fmt.Sprintf("exit must be %v. config: '%v'", expected, config))
		}
	}
}

func TestHost_simple(t *testing.T) {
	manifest := manifest("host.wasm")

	mult := NewHostFunctionWithStack(
		"mult",
		func(ctx context.Context, plugin *CurrentPlugin, stack []uint64) {
			a := DecodeI32(stack[0])
			b := DecodeI32(stack[1])

			stack[0] = EncodeI32(a * b)
		},
		[]ValueType{ValueTypePTR, ValueTypePTR},
		[]ValueType{ValueTypePTR},
	)

	if plugin, ok := pluginInstance(t, manifest, mult); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := "42 x 2 = 84"

			assert.Equal(t, expected, actual)
		}
	}
}

func TestHost_memory(t *testing.T) {
	manifest := manifest("host_memory.wasm")

	mult := NewHostFunctionWithStack(
		"to_upper",
		func(ctx context.Context, plugin *CurrentPlugin, stack []uint64) {
			offset := stack[0]
			buffer, err := plugin.ReadBytes(offset)
			if err != nil {
				panic(err)
			}

			result := bytes.ToUpper(buffer)
			plugin.Logf(LogLevelDebug, "Result: %s", result)

			plugin.Free(offset)

			offset, err = plugin.WriteBytes(result)
			if err != nil {
				panic(err)
			}

			stack[0] = offset
		},
		[]ValueType{ValueTypePTR},
		[]ValueType{ValueTypePTR},
	)

	mult.SetNamespace("host")

	if plugin, ok := pluginInstance(t, manifest, mult); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("run_test", []byte("Frodo"))

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := "HELLO FRODO!"

			assert.Equal(t, expected, actual)
		}
	}
}

func TestHost_multiple(t *testing.T) {
	manifest := manifest("host_multiple.wasm")

	green_message := NewHostFunctionWithStack(
		"hostGreenMessage",
		func(ctx context.Context, plugin *CurrentPlugin, stack []uint64) {
			offset := stack[0]
			input, err := plugin.ReadString(offset)

			if err != nil {
				fmt.Println("🥵", err.Error())
				panic(err)
			}

			message := "🟢:" + string(input)
			offset, err = plugin.WriteString(message)

			if err != nil {
				fmt.Println("🥵", err.Error())
				panic(err)
			}

			stack[0] = offset
		},
		[]ValueType{ValueTypePTR},
		[]ValueType{ValueTypePTR},
	)

	purple_message := NewHostFunctionWithStack(
		"hostPurpleMessage",
		func(ctx context.Context, plugin *CurrentPlugin, stack []uint64) {
			offset := stack[0]
			input, err := plugin.ReadString(offset)

			if err != nil {
				fmt.Println("🥵", err.Error())
				panic(err)
			}

			message := "🟣:" + string(input)
			offset, err = plugin.WriteString(message)

			if err != nil {
				fmt.Println("🥵", err.Error())
				panic(err)
			}

			stack[0] = offset
		},
		[]ValueType{ValueTypePTR},
		[]ValueType{ValueTypePTR},
	)

	hostFunctions := []HostFunction{
		purple_message,
		green_message,
	}

	ctx := context.Background()
	p, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi: true,
	}, hostFunctions)
	if err != nil {
		panic(err)
	}

	pluginInst, err := p.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})
	if err != nil {
		panic(err)
	}

	_, res, err := pluginInst.Call(
		"say_green",
		[]byte("John Doe"),
	)
	assert.Equal(t, "🟢:🫱 Hey from say_green John Doe", string(res))

	_, res, err = pluginInst.Call(
		"say_purple",
		[]byte("Jane Doe"),
	)
	assert.Equal(t, "🟣:👋 Hello from say_purple Jane Doe", string(res))
}

func TestHTTP_allowed(t *testing.T) {
	manifest := manifest("http.wasm")
	manifest.AllowedHosts = []string{"jsonplaceholder.*.com"}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := `
{
	"userId": 1,
	"id": 1,
	"title": "delectus aut autem",
	"completed": false
}`

			assert.JSONEq(t, expected, actual)
		}
	}
}

func TestHTTP_denied(t *testing.T) {
	allowed := []string{
		"", // If no allowed hosts are defined, then all requests are denied
		"google.*"}

	for _, url := range allowed {
		manifest := manifest("http.wasm")
		if url != "" {
			manifest.AllowedHosts = []string{url}
		}

		if plugin, ok := pluginInstance(t, manifest); ok {
			defer plugin.Close(context.Background())

			exit, _, err := plugin.Call("run_test", []byte{})

			assert.Equal(t, uint32(1), exit, "HTTP Request must fail")
			assert.Contains(t, err.Error(), "HTTP request to 'https://jsonplaceholder.typicode.com/todos/1' is not allowed")
		}
	}
}

func TestHTTPHeaders_allowed(t *testing.T) {
	manifest := manifest("http_headers.wasm")
	manifest.AllowedHosts = []string{"extism.org"}

	if plugin, ok := pluginInstanceHttpHeaders(t, manifest); ok {
		defer plugin.Close(context.Background())

		req, _ := json.Marshal(map[string]string{
			"url": "https://extism.org",
		})

		exit, output, err := plugin.Call("http_get", req)

		if assertCall(t, err, exit) {
			headers := map[string]string{}
			err = json.Unmarshal(output, &headers)
			if err != nil {
				t.Error(err)
			}
			assert.Equal(t, "text/html; charset=utf-8", headers["content-type"])
		}
	}
}

func TestHTTPHeaders_denied(t *testing.T) {
	manifest := manifest("http_headers.wasm")
	manifest.AllowedHosts = []string{"extism.org"}

	ctx := context.Background()
	if plugin, ok := pluginInstance(t, manifest); ok {

		defer plugin.Close(ctx)

		req, _ := json.Marshal(map[string]string{
			"url": "https://extism.org",
		})

		exit, output, err := plugin.Call("http_get", req)

		if assertCall(t, err, exit) {
			assert.Equal(t, output, []byte("{}"))

		}
	}
}

func TestLog_default(t *testing.T) {
	manifest := manifest("log.wasm")

	var buf bytes.Buffer
	log.SetOutput(&buf)
	defer func() {
		log.SetOutput(os.Stderr)
	}()

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		SetLogLevel(LogLevelWarn) // Only warn and error logs should be printed to the console
		exit, _, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			logs := buf.String()
			assert.Contains(t, logs, "this is a warning log")
			assert.Contains(t, logs, "this is an error log")
			assert.NotContains(t, logs, "this is a trace log")
			assert.NotContains(t, logs, "this is a debug log")
			assert.NotContains(t, logs, "this is an info log")
		}
	}
}

func TestLog_custom(t *testing.T) {
	manifest := manifest("log.wasm")

	type LogEntry struct {
		message string
		level   LogLevel
	}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		var actual strings.Builder

		var fmtLogMessage = func(level LogLevel, message string) string {
			return fmt.Sprintf("%s: %s\n", level.String(), message)
		}

		plugin.SetLogger(func(level LogLevel, message string) {
			actual.WriteString(fmtLogMessage(level, message))
			switch level {
			case LogLevelDebug:
				assert.Equal(t, level.String(), "DEBUG")
			case LogLevelInfo:
				assert.Equal(t, level.String(), "INFO")
			case LogLevelWarn:
				assert.Equal(t, level.String(), "WARN")
			case LogLevelError:
				assert.Equal(t, level.String(), "ERROR")
			case LogLevelTrace:
				assert.Equal(t, level.String(), "TRACE")
			}
		})

		SetLogLevel(LogLevelTrace)

		exit, _, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			expected := []LogEntry{
				{message: "this is a trace log", level: LogLevelTrace},
				{message: "this is a debug log", level: LogLevelDebug},
				{message: "this is an info log", level: LogLevelInfo},
				{message: "this is a warning log", level: LogLevelWarn},
				{message: "this is an error log", level: LogLevelError},
			}
			actualLogs := actual.String()
			for _, log := range expected {
				assert.Contains(t, actualLogs, fmtLogMessage(log.level, log.message))
			}
		}

		SetLogLevel(LogLevelWarn)
		actual.Reset()

		exit, _, err = plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			expected := []LogEntry{
				{message: "this is a warning log", level: LogLevelWarn},
				{message: "this is an error log", level: LogLevelError},
			}
			expectedNot := []LogEntry{
				{message: "this is a trace log", level: LogLevelTrace},
				{message: "this is a debug log", level: LogLevelDebug},
				{message: "this is an info log", level: LogLevelInfo},
			}
			actualLogs := actual.String()
			for _, log := range expected {
				assert.Contains(t, actualLogs, fmtLogMessage(log.level, log.message))
			}
			for _, log := range expectedNot {
				assert.NotContains(t, actualLogs, fmtLogMessage(log.level, log.message))
			}
		}
	}
}

func TestTimeout(t *testing.T) {
	manifest := manifest("sleep.wasm")
	manifest.Timeout = 100            // 100ms
	manifest.Config["duration"] = "3" // sleep for 3 seconds

	config := PluginConfig{
		EnableWasi: true,
	}

	plugin, err := NewCompiledPlugin(context.Background(), manifest, config, nil)
	if err != nil {
		t.Errorf("Could not create plugin: %v", err)
	}

	instance, err := plugin.Instance(context.Background(), PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})

	defer instance.Close(context.Background())

	exit, _, err := instance.Call("run_test", []byte{})

	assert.Equal(t, sys.ExitCodeDeadlineExceeded, exit, "Exit code must be `sys.ExitCodeDeadlineExceeded`")
	assert.Equal(t, "module closed with context deadline exceeded", err.Error())
}

func TestCancel(t *testing.T) {
	manifest := manifest("sleep.wasm")
	manifest.Config["duration"] = "3" // sleep for 3 seconds

	ctx := context.Background()

	plugin, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi:    true,
		RuntimeConfig: wazero.NewRuntimeConfig().WithCloseOnContextDone(true),
	}, nil)
	if err != nil {
		t.Errorf("Could not create plugin: %v", err)
	}
	defer plugin.Close(ctx)

	instance, err := plugin.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})
	if err != nil {
		t.Errorf("Could not create plugin instance: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		time.Sleep(100 * time.Millisecond)
		cancel()
	}()

	exit, _, err := instance.CallWithContext(ctx, "run_test", []byte{})

	assert.Equal(t, sys.ExitCodeContextCanceled, exit, "Exit code must be `sys.ExitCodeContextCanceled`")
	assert.Equal(t, "module closed with context canceled", err.Error())
}

func TestVar(t *testing.T) {
	manifest := manifest("var.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		plugin.Var["a"] = uintToLEBytes(10)

		exit, _, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			actual := uintFromLEBytes(plugin.Var["a"])
			expected := uint(20)

			assert.Equal(t, expected, actual)
		}

		exit, _, err = plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			actual := uintFromLEBytes(plugin.Var["a"])
			expected := uint(40)

			assert.Equal(t, expected, actual)
		}
	}

}

func TestNoVars(t *testing.T) {
	manifest := manifest("var.wasm")
	manifest.Memory = &ManifestMemory{MaxVarBytes: 0}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		plugin.Var["a"] = uintToLEBytes(10)

		_, _, err := plugin.Call("run_test", []byte{})

		if err == nil {
			t.Fail()
		}
	}

}

func TestFS(t *testing.T) {
	manifest := manifest("fs.wasm")
	manifest.AllowedPaths = map[string]string{
		"testdata": "/mnt",
	}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("run_test", []byte{})

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := "hello world!"

			assert.Equal(t, expected, actual)
		}
	}
}

func TestReadOnlyMount(t *testing.T) {
	manifest := manifest("read_write.wasm")
	manifest.AllowedPaths = map[string]string{
		"ro:testdata": "/mnt",
	}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())
		plugin.Config["path"] = "/mnt/test.txt"

		exit, output, err := plugin.Call("try_read", []byte{})

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := "hello world!"

			assert.Equal(t, expected, actual)
		}

		_, _, err = plugin.Call("try_write", []byte("hello hello!"))

		assert.NotNil(t, err, "Write must fail")
		assert.Contains(t, err.Error(), "Failed to write file")
	}
}

func TestCountVowels(t *testing.T) {
	manifest := manifest("count_vowels.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("count_vowels", []byte("hello world"))

		if assertCall(t, err, exit) {
			expected := 3 // 3 vowels

			var actual map[string]int
			json.Unmarshal(output, &actual)

			assert.Equal(t, expected, actual["count"])
		}
	}
}

func TestMultipleCallsOutput(t *testing.T) {
	manifest := manifest("count_vowels.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, output1, err := plugin.Call("count_vowels", []byte("aaa"))

		if !assertCall(t, err, exit) {
			return
		}

		exit, output2, err := plugin.Call("count_vowels", []byte("bbba"))

		if !assertCall(t, err, exit) {
			return
		}

		assert.Equal(t, `{"count":3,"total":3,"vowels":"aeiouAEIOU"}`, string(output1))
		assert.Equal(t, `{"count":1,"total":4,"vowels":"aeiouAEIOU"}`, string(output2))
	}
}

func TestHelloHaskell(t *testing.T) {
	var buf bytes.Buffer
	log.SetOutput(&buf)
	defer func() {
		log.SetOutput(os.Stderr)
	}()

	manifest := manifest("hello_haskell.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		SetLogLevel(LogLevelTrace)
		plugin.Config["greeting"] = "Howdy"

		exit, output, err := plugin.Call("testing", []byte("John"))

		if assertCall(t, err, exit) {
			actual := string(output)
			expected := "Howdy, John"

			assert.Equal(t, expected, actual)

			logs := buf.String()

			assert.Contains(t, logs, "Initialized Haskell language runtime.")
		}
	}
}

func TestJsonManifest(t *testing.T) {
	m := `
	{
		"wasm": [
		  {
			"path": "wasm/sleep.wasm"
		  }
		],
		"memory": {
		  "max_pages": 100
		},
		"config": {
		  "key1": "value1",
		  "key2": "value2",
		  "duration": "3"
		},
		"timeout_ms": 100
	}
	`

	manifest := Manifest{}
	err := manifest.UnmarshalJSON([]byte(m))
	if err != nil {
		t.Error(err)
	}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, _, err := plugin.Call("run_test", []byte{})

		assert.Equal(t, sys.ExitCodeDeadlineExceeded, exit, "Exit code must be `sys.ExitCodeDeadlineExceeded`")
		assert.Equal(t, "module closed with context deadline exceeded", err.Error())
	}
}

func TestInputOffset(t *testing.T) {
	manifest := manifest("input_offset.wasm")

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		input_data := []byte("hello world")
		exit, output, err := plugin.Call("input_offset_length", input_data)

		if assertCall(t, err, exit) {
			assert.Equal(t, len(input_data), int(output[0]))
		}
	}
}

func TestObserve(t *testing.T) {
	ctx := context.Background()

	var buf bytes.Buffer
	log.SetOutput(&buf)

	adapter := stdout.NewStdoutAdapter()
	adapter.Start(ctx)

	manifest := manifest("nested.c.instr.wasm")

	config := PluginConfig{
		EnableWasi:     true,
		ObserveAdapter: adapter.AdapterBase,
		ObserveOptions: &observe.Options{
			SpanFilter:        &observe.SpanFilter{MinDuration: 1 * time.Nanosecond},
			ChannelBufferSize: 1024,
		},
	}

	// Plugin 1
	plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
	if err != nil {
		panic(err)
	}

	instance, err := plugin.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})
	if err != nil {
		panic(err)
	}

	meta := map[string]string{
		"http.url":         "https://example.com/my-endpoint",
		"http.status_code": "200",
		"http.client_ip":   "192.168.1.0",
	}

	instance.traceCtx.Metadata(meta)

	_, _, _ = instance.Call("_start", []byte("hello world"))
	plugin.Close(ctx)

	// HACK: make sure we give enough time for the events to get flushed
	time.Sleep(100 * time.Millisecond)

	actual := buf.String()
	assert.Contains(t, actual, "  Call to _start took")
	assert.Contains(t, actual, "      Call to main took")
	assert.Contains(t, actual, "        Call to one took")
	assert.Contains(t, actual, "          Call to two took")
	assert.Contains(t, actual, "            Call to three took")
	assert.Contains(t, actual, "              Call to printf took")

	// Reset underlying buffer
	buf.Reset()

	// Plugin 2
	plugin2, err := NewCompiledPlugin(ctx, manifest, config, nil)
	if err != nil {
		panic(err)
	}

	instance2, err := plugin2.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})
	if err != nil {
		panic(err)
	}

	_, _, _ = instance2.Call("_start", []byte("hello world"))
	plugin2.Close(ctx)

	// HACK: make sure we give enough time for the events to get flushed
	time.Sleep(100 * time.Millisecond)

	actual2 := buf.String()
	assert.Contains(t, actual2, "  Call to _start took")
	assert.Contains(t, actual2, "      Call to main took")
	assert.Contains(t, actual2, "        Call to one took")
	assert.Contains(t, actual2, "          Call to two took")
	assert.Contains(t, actual2, "            Call to three took")
	assert.Contains(t, actual2, "              Call to printf took")
}

// make sure cancelling the context given to NewCompiledPlugin doesn't affect plugin calls
func TestContextCancel(t *testing.T) {
	manifest := manifest("sleep.wasm")
	manifest.Config["duration"] = "0" // sleep for 0 seconds

	ctx, cancel := context.WithCancel(context.Background())
	config := PluginConfig{
		EnableWasi:    true,
		RuntimeConfig: wazero.NewRuntimeConfig().WithCloseOnContextDone(true),
	}

	plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
	if err != nil {
		t.Errorf("Could not create plugin: %v", err)
	}

	instance, err := plugin.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})

	defer plugin.Close(context.Background())
	cancel() // cancel the parent context

	exit, out, err := instance.CallWithContext(context.Background(), "run_test", []byte{})

	if assertCall(t, err, exit) {
		assert.Equal(t, "slept for 0 seconds", string(out))
	}
}

// make sure we can still turn on experimental wazero features
func TestEnableExperimentalFeature(t *testing.T) {
	var buf bytes.Buffer

	// Set context to one that has an experimental listener
	ctx := experimental.WithFunctionListenerFactory(context.Background(), logging.NewHostLoggingListenerFactory(&buf, logging.LogScopeAll))

	manifest := manifest("sleep.wasm")
	manifest.Config["duration"] = "0" // sleep for 0 seconds

	config := PluginConfig{
		EnableWasi:    true,
		RuntimeConfig: wazero.NewRuntimeConfig().WithCloseOnContextDone(true),
	}

	plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
	if err != nil {
		t.Errorf("Could not create plugin: %v", err)
	}
	defer plugin.Close(context.Background())

	instance, err := plugin.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime(),
	})
	defer instance.Close(ctx)

	var buf2 bytes.Buffer
	ctx = experimental.WithFunctionListenerFactory(context.Background(), logging.NewHostLoggingListenerFactory(&buf2, logging.LogScopeAll))
	exit, out, err := instance.CallWithContext(ctx, "run_test", []byte{})

	if assertCall(t, err, exit) {
		assert.Equal(t, "slept for 0 seconds", string(out))

		assert.NotEmpty(t, buf.String())
		assert.Empty(t, buf2.String())
	}
}

func TestModuleLinking(t *testing.T) {
	manifest := Manifest{
		Wasm: []Wasm{
			WasmFile{
				Path: "wasm/lib.wasm",
				Name: "lib",
			},
			WasmFile{
				Path: "wasm/main.wasm",
				Name: "main",
			},
		},
	}

	if plugin, ok := pluginInstance(t, manifest); ok {
		defer plugin.Close(context.Background())

		exit, output, err := plugin.Call("run_test", []byte("benjamin"))

		if assertCall(t, err, exit) {
			expected := "Hello, BENJAMIN"

			actual := string(output)

			assert.Equal(t, expected, actual)
		}
	}
}

func TestModuleLinkingMultipleInstances(t *testing.T) {
	manifest := Manifest{
		Wasm: []Wasm{
			WasmFile{
				Path: "wasm/lib.wasm",
				Name: "lib",
			},
			WasmFile{
				Path: "wasm/main.wasm",
				Name: "main",
			},
		},
	}

	ctx := context.Background()
	config := wasiPluginConfig()

	compiledPlugin, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi: true,
	}, []HostFunction{})

	if err != nil {
		t.Fatalf("Could not create plugin: %v", err)
	}

	for i := 0; i < 3; i++ {
		plugin, err := compiledPlugin.Instance(ctx, config)
		if err != nil {
			t.Fatalf("Could not create plugin instance: %v", err)
		}
		// purposefully not closing the plugin instance

		for j := 0; j < 3; j++ {

			exit, output, err := plugin.Call("run_test", []byte("benjamin"))

			if assertCall(t, err, exit) {
				expected := "Hello, BENJAMIN"

				actual := string(output)

				assert.Equal(t, expected, actual)
			}
		}
	}
}

func TestCompiledModuleMultipleInstances(t *testing.T) {
	manifest := Manifest{
		Wasm: []Wasm{
			WasmFile{
				Path: "wasm/count_vowels.wasm",
				Name: "main",
			},
		},
	}

	ctx := context.Background()
	config := wasiPluginConfig()

	compiledPlugin, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi: true,
	}, []HostFunction{})

	if err != nil {
		t.Fatalf("Could not create plugin: %v", err)
	}

	var wg sync.WaitGroup
	numInstances := 300

	// Create and test instances in parallel
	for i := 0; i < numInstances; i++ {
		wg.Add(1)
		go func(instanceNum int) {
			defer wg.Done()

			plugin, err := compiledPlugin.Instance(ctx, config)
			if err != nil {
				t.Errorf("Could not create plugin instance %d: %v", instanceNum, err)
				return
			}
			// purposefully not closing the plugin instance

			// Sequential calls for this instance
			for j := 0; j < 3; j++ {
				exit, _, err := plugin.Call("count_vowels", []byte("benjamin"))
				if err != nil {
					t.Errorf("Instance %d, call %d failed: %v", instanceNum, j, err)
					return
				}
				if exit != 0 {
					t.Errorf("Instance %d, call %d returned non-zero exit code: %d", instanceNum, j, exit)
				}
			}
		}(i)
	}
	wg.Wait()
}

func TestMultipleCallsOutputParallel(t *testing.T) {
	manifest := manifest("count_vowels.wasm")
	numInstances := 300

	var wg sync.WaitGroup

	// Create and test instances in parallel
	for i := 0; i < numInstances; i++ {
		wg.Add(1)
		go func(instanceNum int) {
			defer wg.Done()

			if plugin, ok := pluginInstance(t, manifest); ok {
				defer plugin.Close(context.Background())

				// Sequential calls for this instance
				exit, output1, err := plugin.Call("count_vowels", []byte("aaa"))
				if !assertCall(t, err, exit) {
					return
				}

				exit, output2, err := plugin.Call("count_vowels", []byte("bbba"))
				if !assertCall(t, err, exit) {
					return
				}

				assert.Equal(t, `{"count":3,"total":3,"vowels":"aeiouAEIOU"}`, string(output1))
				assert.Equal(t, `{"count":1,"total":4,"vowels":"aeiouAEIOU"}`, string(output2))
			}
		}(i)
	}

	wg.Wait()
}

func BenchmarkInitialize(b *testing.B) {
	ctx := context.Background()
	cache := wazero.NewCompilationCache()
	defer cache.Close(ctx)

	b.ResetTimer()
	b.Run("noop", func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i < b.N; i++ {
			manifest := Manifest{Wasm: []Wasm{WasmFile{Path: "wasm/noop.wasm"}}}

			config := PluginConfig{
				EnableWasi:    true,
				RuntimeConfig: wazero.NewRuntimeConfig(),
			}

			plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
			if err != nil {
				panic(err)
			}

			_, err = plugin.Instance(ctx, PluginInstanceConfig{
				ModuleConfig: wazero.NewModuleConfig(),
			})
			if err != nil {
				panic(err)
			}
		}
	})
}

func BenchmarkInitializeWithCache(b *testing.B) {
	ctx := context.Background()
	cache := wazero.NewCompilationCache()
	defer cache.Close(ctx)

	b.ResetTimer()
	b.Run("noop", func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i < b.N; i++ {
			manifest := Manifest{Wasm: []Wasm{WasmFile{Path: "wasm/noop.wasm"}}}

			config := PluginConfig{
				EnableWasi:    true,
				RuntimeConfig: wazero.NewRuntimeConfig().WithCompilationCache(cache),
			}

			plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
			if err != nil {
				panic(err)
			}

			_, err = plugin.Instance(ctx, PluginInstanceConfig{
				ModuleConfig: wazero.NewModuleConfig(),
			})
			if err != nil {
				panic(err)
			}
		}
	})
}

func BenchmarkNoop(b *testing.B) {
	ctx := context.Background()
	cache := wazero.NewCompilationCache()
	defer cache.Close(ctx)

	manifest := Manifest{Wasm: []Wasm{WasmFile{Path: "wasm/noop.wasm"}}}

	config := PluginConfig{
		EnableWasi:    true,
		RuntimeConfig: wazero.NewRuntimeConfig().WithCompilationCache(cache),
	}

	plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
	if err != nil {
		panic(err)
	}
	defer plugin.Close(ctx)

	instance, err := plugin.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig(),
	})
	if err != nil {
		panic(err)
	}

	b.ResetTimer()

	b.Run("noop", func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i < b.N; i++ {
			_, _, err := instance.Call("run_test", []byte{})
			if err != nil {
				panic(err)
			}
		}
	})
}

var (
	Regex2048 = "BYwnOjWhprPmDncp8qpQ5CY4r1RGZuqKLBowmtMCd test ETjLOG685YC4RIjXB0HadNpqYS4M7GPGUVAKRZRC1ibqQqGnuzqX2Hjosm6MKNCp5QifX7Up2phqkFqkjpSu3k59oi6M5YbTMiy4JukVFx2402IlrHU1McK7US0skB1cF0W2ZDpsypNmGJRXRMY0pPsYbw7G2a0xJnhTITXcuF5xJWR1rz5zdGZQbbjZoHZcEnveDFq5kOmCVc test DsJVHTsAlypLI9sVtbTLwmE1DG2C6AgUo3GO1DpCx3jV43oXUxaTVJqZO13AYqvNPbxizYZ5BckZFBbJybY3Vnm20Sm7nXbwZs5N2ugz3EpUQvXwqHdHWzc1T8uKPD5LTDM8UBpVoF test 9G3mWarrp43SvoidITriFhzHmyVWNd6n2LIVocr3pOai4DOlkAn7QDup6z6spMAf8UcI4wbfoSzG0k5Qy1rGBhPaJKJRW2 MC9ma3U3rnjAOBtEUHZ2qfOUpfMNgPlGpvzr4IGNNFf9RFlF7yRUBvRnYxyonIWPPiR1x1wWgxc20o5cW4GU7kytAOuGlpzpykcAxCJLLP6wJegaMhAeb8xBLpuBetNEbfcyyOcJBun5BhmFOmv8 test IvICWx2wlYZ61YDBpPcIpqnMb9MHwT8GroC1YITZBlNGBHMpAe4d2sNZe9d0Wvfbv5mMo30Bm1Pa5S3x38jgu6y0BaqZl9GhlukE9CqPJGUsJZ5suDH19WiOrvz7mXwXhi4lWm1YdwNi0xhVnXITtmKq5rikIS6dul1USgDf3TwyLYpyCG46Xj92PssJmnhPdH1WAnvXY sbs8RaemyqmPggtGNwU2JjuPjdmQRakIusv2WimN7zG8R8Pf1225IAJ2j8aiZBrxnjmrucaYOQCrLm7e2Q5q8 test HOkCEJJGHVLYJtGgHKa1PRQ5qCcsIAUdkW3yRfdulutteLe3We9z9XQvWuTYMLDPpOJqMzDNTGpTYts7AL8pFog1k82XVuMZ6ItccxOBpuzDcahH4wDqCGjak8qPVxmnrGmSsrdUHVz6SrScElMo0nOF8RIpYAVdJr5NxWIK1uzc1iIiZnbUD6uDNmBkmfec6IgK6aqnEZaGLDJXDHSYfzWUOi7y3KNPl0CghL9BId8v4040mCKMfmdthWWLJ2tpWIo1482ghiU5 2qtrzgFgYKfyfr4X6FXzN3hM3bLnuwItQrTCEp3BYz79bCAaQGhicZzqE83Mh2 test IIVID622qlEyVEGuEmNJ5JteEzbpklhTKnVMflzzWyWbZe6kIgeUr9mxWjkJGisvRbZKwfnojeC82M1nHgUa4k46x7Dw7mL3rChORjBxBMYjFeOvCsT6kEo3vPeachLUKdkExJbr9Yei0fKyOFSDlxpFhlRKuwGxXu4jGo4CzKDsVsahqzC9iGw53bHiw0V4Pwmdhzv482s3zU9XLTgQr6GuL1I0kSfh9BkVoK5fFvg1hm7ECrt6p8q3kLVjxte EK9W9q2q9etMaPLymcCRZ0XauMDzJY08JeVvovnT2g5hxE7UGW1 test YRotQUivrrXQnhEw55faznZZBU1ULVs4BfYkIkEfS91NetBhona6zrzDwMsXi0FJjdaiJ25lvetPDaMzUs0l6nfkGkVyU376mFPfPkpBKZR2z2Xwzxndi0SkUnqm8jCa7iq2oSJstTdUXtCK2xTXMIh7tiuPVftit GFYQXXI3vY QFe1xShWJgFAqYguQ8gcxMPSzMlyDaPmMuTPgFZDM0cd test NS3fTggxBa4p5jgS4S0nhae05RkYkXGzuNMXeu6IoR9PFqVFnXcBYD0Ld9otrAiqUuIGYGmAjm3Wx29va2UtIFaRhL02ckRfycz3BGfwqYl3TGtjWdKjmxn1WreRIIq5gkbWJws5VQsov0V2U8pGedj N2RDqWgh2tFiJA9fmytgRgqSnqxIwyBMgY5RnE6CZ0 test Iv4QPiWMu0oG70e4nSNtG13O test "
	Match2048 = "BYwnOjWhprPmDncp8qpQ5CY4r1RGZuqKLBowmtMCd wasm ETjLOG685YC4RIjXB0HadNpqYS4M7GPGUVAKRZRC1ibqQqGnuzqX2Hjosm6MKNCp5QifX7Up2phqkFqkjpSu3k59oi6M5YbTMiy4JukVFx2402IlrHU1McK7US0skB1cF0W2ZDpsypNmGJRXRMY0pPsYbw7G2a0xJnhTITXcuF5xJWR1rz5zdGZQbbjZoHZcEnveDFq5kOmCVc wasm DsJVHTsAlypLI9sVtbTLwmE1DG2C6AgUo3GO1DpCx3jV43oXUxaTVJqZO13AYqvNPbxizYZ5BckZFBbJybY3Vnm20Sm7nXbwZs5N2ugz3EpUQvXwqHdHWzc1T8uKPD5LTDM8UBpVoF wasm 9G3mWarrp43SvoidITriFhzHmyVWNd6n2LIVocr3pOai4DOlkAn7QDup6z6spMAf8UcI4wbfoSzG0k5Qy1rGBhPaJKJRW2 MC9ma3U3rnjAOBtEUHZ2qfOUpfMNgPlGpvzr4IGNNFf9RFlF7yRUBvRnYxyonIWPPiR1x1wWgxc20o5cW4GU7kytAOuGlpzpykcAxCJLLP6wJegaMhAeb8xBLpuBetNEbfcyyOcJBun5BhmFOmv8 wasm IvICWx2wlYZ61YDBpPcIpqnMb9MHwT8GroC1YITZBlNGBHMpAe4d2sNZe9d0Wvfbv5mMo30Bm1Pa5S3x38jgu6y0BaqZl9GhlukE9CqPJGUsJZ5suDH19WiOrvz7mXwXhi4lWm1YdwNi0xhVnXITtmKq5rikIS6dul1USgDf3TwyLYpyCG46Xj92PssJmnhPdH1WAnvXY sbs8RaemyqmPggtGNwU2JjuPjdmQRakIusv2WimN7zG8R8Pf1225IAJ2j8aiZBrxnjmrucaYOQCrLm7e2Q5q8 wasm HOkCEJJGHVLYJtGgHKa1PRQ5qCcsIAUdkW3yRfdulutteLe3We9z9XQvWuTYMLDPpOJqMzDNTGpTYts7AL8pFog1k82XVuMZ6ItccxOBpuzDcahH4wDqCGjak8qPVxmnrGmSsrdUHVz6SrScElMo0nOF8RIpYAVdJr5NxWIK1uzc1iIiZnbUD6uDNmBkmfec6IgK6aqnEZaGLDJXDHSYfzWUOi7y3KNPl0CghL9BId8v4040mCKMfmdthWWLJ2tpWIo1482ghiU5 2qtrzgFgYKfyfr4X6FXzN3hM3bLnuwItQrTCEp3BYz79bCAaQGhicZzqE83Mh2 wasm IIVID622qlEyVEGuEmNJ5JteEzbpklhTKnVMflzzWyWbZe6kIgeUr9mxWjkJGisvRbZKwfnojeC82M1nHgUa4k46x7Dw7mL3rChORjBxBMYjFeOvCsT6kEo3vPeachLUKdkExJbr9Yei0fKyOFSDlxpFhlRKuwGxXu4jGo4CzKDsVsahqzC9iGw53bHiw0V4Pwmdhzv482s3zU9XLTgQr6GuL1I0kSfh9BkVoK5fFvg1hm7ECrt6p8q3kLVjxte EK9W9q2q9etMaPLymcCRZ0XauMDzJY08JeVvovnT2g5hxE7UGW1 wasm YRotQUivrrXQnhEw55faznZZBU1ULVs4BfYkIkEfS91NetBhona6zrzDwMsXi0FJjdaiJ25lvetPDaMzUs0l6nfkGkVyU376mFPfPkpBKZR2z2Xwzxndi0SkUnqm8jCa7iq2oSJstTdUXtCK2xTXMIh7tiuPVftit GFYQXXI3vY QFe1xShWJgFAqYguQ8gcxMPSzMlyDaPmMuTPgFZDM0cd wasm NS3fTggxBa4p5jgS4S0nhae05RkYkXGzuNMXeu6IoR9PFqVFnXcBYD0Ld9otrAiqUuIGYGmAjm3Wx29va2UtIFaRhL02ckRfycz3BGfwqYl3TGtjWdKjmxn1WreRIIq5gkbWJws5VQsov0V2U8pGedj N2RDqWgh2tFiJA9fmytgRgqSnqxIwyBMgY5RnE6CZ0 wasm Iv4QPiWMu0oG70e4nSNtG13O wasm "

	Regex4096 = Regex2048 + Regex2048
	Match4096 = Match2048 + Match2048

	Regex8192 = Regex4096 + Regex4096
	Match8192 = Match4096 + Match4096

	Regex16384 = Regex8192 + Regex8192
	Match16384 = Match8192 + Match8192

	Regex32768 = Regex16384 + Regex16384
	Match32768 = Match16384 + Match16384

	Regex65536 = Regex32768 + Regex32768
	Match65536 = Match32768 + Match32768
)

func BenchmarkReplace(b *testing.B) {
	ctx := context.Background()
	cache := wazero.NewCompilationCache()
	defer cache.Close(ctx)

	manifest := Manifest{Wasm: []Wasm{WasmFile{Path: "wasm/replace.wasm"}}}

	config := PluginConfig{
		EnableWasi:    true,
		RuntimeConfig: wazero.NewRuntimeConfig().WithCompilationCache(cache),
	}

	plugin, err := NewCompiledPlugin(ctx, manifest, config, nil)
	if err != nil {
		panic(err)
	}
	defer plugin.Close(ctx)

	instance, err := plugin.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig(),
	})

	b.ResetTimer()

	inputs := map[string][]byte{
		"empty": {},
		"2048":  []byte(Regex2048),
		"4096":  []byte(Regex4096),
		"8192":  []byte(Regex8192),
		"16383": []byte(Regex16384),
		"32768": []byte(Regex32768),
	}

	expected := map[string][]byte{
		"empty": {},
		"2048":  []byte(Match2048),
		"4096":  []byte(Match4096),
		"8192":  []byte(Match8192),
		"16383": []byte(Match16384),
		"32768": []byte(Match32768),
	}

	for k, v := range inputs {
		expected := expected[k]
		b.Run(k, func(b *testing.B) {
			input := v
			b.SetBytes(int64(len(input)))
			b.ReportAllocs()

			for i := 0; i < b.N; i++ {
				_, out, err := instance.Call("run_test", input)
				if err != nil {
					fmt.Println("SOMETHING BAD HAPPENED: ", err)
					panic(err)
				}

				if !equal(out, expected) {
					fmt.Println(string(out))
					panic("invalid regex match")
				}
			}
		})
	}
}

func wasiPluginConfig() PluginInstanceConfig {
	config := PluginInstanceConfig{
		ModuleConfig: wazero.NewModuleConfig().WithSysWalltime().WithStdout(os.Stdout).WithStderr(os.Stderr),
	}
	return config
}

func manifest(name string) Manifest {
	manifest := Manifest{
		Wasm: []Wasm{
			WasmFile{
				Path: fmt.Sprintf("wasm/%v", name),
				Hash: "",
				Name: "main",
			},
		},
		Config:       make(map[string]string),
		AllowedHosts: []string{},
		AllowedPaths: make(map[string]string),
	}
	return manifest
}

func pluginInstance(t *testing.T, manifest Manifest, funcs ...HostFunction) (*Plugin, bool) {
	ctx := context.Background()
	config := wasiPluginConfig()

	plugin, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi: true,
	}, funcs)

	if err != nil {
		t.Errorf("Could not create plugin: %v", err)
		return nil, false
	}

	instance, err := plugin.Instance(ctx, config)
	if err != nil {
		t.Errorf("Could not create plugin instance: %v", err)
		return nil, false
	}

	return instance, true
}

func pluginInstanceHttpHeaders(t *testing.T, manifest Manifest, funcs ...HostFunction) (*Plugin, bool) {
	ctx := context.Background()
	config := wasiPluginConfig()

	plugin, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi:                true,
		EnableHttpResponseHeaders: true,
	}, funcs)

	if err != nil {
		t.Errorf("Could not create plugin: %v", err)
		return nil, false
	}

	instance, err := plugin.Instance(ctx, config)
	if err != nil {
		t.Errorf("Could not create plugin instance: %v", err)
		return nil, false
	}

	return instance, true
}

func plugin(t *testing.T, manifest Manifest, funcs ...HostFunction) *CompiledPlugin {
	ctx := context.Background()
	p, err := NewCompiledPlugin(ctx, manifest, PluginConfig{
		EnableWasi:    true,
		RuntimeConfig: wazero.NewRuntimeConfigCompiler(),
	}, funcs)
	require.NoError(t, err)
	return p
}

func assertCall(t *testing.T, err error, exit uint32) bool {
	if err != nil {
		t.Error(err)
		return false
	} else if exit != 0 {
		t.Errorf("Call failed. Exit code: %v", exit)
		return false
	}

	return true
}

func uintToLEBytes(num uint) []byte {
	var bytes [4]byte
	bytes[0] = byte(num)
	bytes[1] = byte(num >> 8)
	bytes[2] = byte(num >> 16)
	bytes[3] = byte(num >> 24)
	return bytes[:]
}

func uintFromLEBytes(bytes []byte) uint {
	return uint(bytes[0]) | uint(bytes[1])<<8 | uint(bytes[2])<<16 | uint(bytes[3])<<24
}


================================================
File: host.go
================================================
package extism

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"unsafe"

	// TODO: is there a better package for this?
	"github.com/gobwas/glob"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
)

type ValueType = byte

const (
	// ValueTypeI32 is a 32-bit integer.
	ValueTypeI32 = api.ValueTypeI32
	// ValueTypeI64 is a 64-bit integer.
	ValueTypeI64 = api.ValueTypeI64
	// ValueTypeF32 is a 32-bit floating point number.
	ValueTypeF32 = api.ValueTypeF32
	// ValueTypeF64 is a 64-bit floating point number.
	ValueTypeF64 = api.ValueTypeF64
	// ValueTypePTR represents a pointer to an Extism memory block. Alias for ValueTypeI64
	ValueTypePTR = ValueTypeI64
)

// HostFunctionStackCallback is a Function implemented in Go instead of a wasm binary.
// The plugin parameter is the calling plugin, used to access memory or
// exported functions and logging.
//
// The stack is includes any parameters encoded according to their ValueType.
// Its length is the max of parameter or result length. When there are results,
// write them in order beginning at index zero. Do not use the stack after the
// function returns.
//
// Here's a typical way to read three parameters and write back one.
//
//	// read parameters in index order
//	argv, argvBuf := DecodeU32(inputs[0]), DecodeU32(inputs[1])
//
//	// write results back to the stack in index order
//	stack[0] = EncodeU32(ErrnoSuccess)
//
// This function can be non-deterministic or cause side effects. It also
// has special properties not defined in the WebAssembly Core specification.
// Notably, this uses the caller's memory (via Module.Memory). See
// https://www.w3.org/TR/wasm-core-1/#host-functions%E2%91%A0
//
// To safely decode/encode values from/to the uint64 inputs/ouputs, users are encouraged to use
// Extism's EncodeXXX or DecodeXXX functions.
type HostFunctionStackCallback func(ctx context.Context, p *CurrentPlugin, stack []uint64)

// HostFunction represents a custom function defined by the host.
type HostFunction struct {
	stackCallback HostFunctionStackCallback
	Name          string
	Namespace     string
	Params        []api.ValueType
	Returns       []api.ValueType
}

func (f *HostFunction) SetNamespace(namespace string) {
	f.Namespace = namespace
}

// NewHostFunctionWithStack creates a new instance of a HostFunction, which is designed
// to provide custom functionality in a given host environment.
// Here's an example multiplication function that loads operands from memory:
//
//	 mult := NewHostFunctionWithStack(
//		"mult",
//		func(ctx context.Context, plugin *CurrentPlugin, stack []uint64) {
//			a := DecodeI32(stack[0])
//			b := DecodeI32(stack[1])
//
//			stack[0] = EncodeI32(a * b)
//		},
//		[]ValueType{ValueTypeI64, ValueTypeI64},
//		ValueTypeI64
//	 )
func NewHostFunctionWithStack(
	name string,
	callback HostFunctionStackCallback,
	params []ValueType,
	returnTypes []ValueType) HostFunction {

	return HostFunction{
		stackCallback: callback,
		Name:          name,
		Namespace:     "extism:host/user",
		Params:        params,
		Returns:       returnTypes,
	}
}

type CurrentPlugin struct {
	plugin *Plugin
}

func (p *Plugin) currentPlugin() *CurrentPlugin {
	return &CurrentPlugin{p}
}

func (p *CurrentPlugin) Log(level LogLevel, message string) {
	p.plugin.Log(level, message)
}

func (p *CurrentPlugin) Logf(level LogLevel, format string, args ...any) {
	p.plugin.Logf(level, format, args...)
}

// Memory returns the plugin's WebAssembly memory interface.
func (p *CurrentPlugin) Memory() api.Memory {
	return p.plugin.Memory()
}

// Alloc a new memory block of the given length, returning its offset
func (p *CurrentPlugin) Alloc(n uint64) (uint64, error) {
	return p.AllocWithContext(context.Background(), n)
}

// Alloc a new memory block of the given length, returning its offset
func (p *CurrentPlugin) AllocWithContext(ctx context.Context, n uint64) (uint64, error) {
	out, err := p.plugin.extism.ExportedFunction("alloc").Call(ctx, uint64(n))
	if err != nil {
		return 0, err
	} else if len(out) != 1 {
		return 0, fmt.Errorf("expected 1 return, go %v", len(out))
	}

	return uint64(out[0]), nil
}

// Free the memory block specified by the given offset
func (p *CurrentPlugin) Free(offset uint64) error {
	return p.FreeWithContext(context.Background(), offset)
}

// Free the memory block specified by the given offset
func (p *CurrentPlugin) FreeWithContext(ctx context.Context, offset uint64) error {
	_, err := p.plugin.extism.ExportedFunction("free").Call(ctx, uint64(offset))
	if err != nil {
		return err
	}

	return nil
}

// Length returns the number of bytes allocated at the specified offset
func (p *CurrentPlugin) Length(offs uint64) (uint64, error) {
	return p.LengthWithContext(context.Background(), offs)
}

// Length returns the number of bytes allocated at the specified offset
func (p *CurrentPlugin) LengthWithContext(ctx context.Context, offs uint64) (uint64, error) {
	out, err := p.plugin.extism.ExportedFunction("length").Call(ctx, uint64(offs))
	if err != nil {
		return 0, err
	} else if len(out) != 1 {
		return 0, fmt.Errorf("expected 1 return, go %v", len(out))
	}

	return uint64(out[0]), nil
}

// Write a string to wasm memory and return the offset
func (p *CurrentPlugin) WriteString(s string) (uint64, error) {
	return p.WriteBytes([]byte(s))
}

// WriteBytes writes a string to wasm memory and return the offset
func (p *CurrentPlugin) WriteBytes(b []byte) (uint64, error) {
	ptr, err := p.Alloc(uint64(len(b)))
	if err != nil {
		return 0, err
	}

	ok := p.Memory().Write(uint32(ptr), b)
	if !ok {
		return 0, fmt.Errorf("failed to write to memory")
	}

	return ptr, nil
}

// ReadString reads a string from wasm memory
func (p *CurrentPlugin) ReadString(offset uint64) (string, error) {
	buffer, err := p.ReadBytes(offset)
	if err != nil {
		return "", err
	}

	return string(buffer), nil
}

// ReadBytes reads a byte array from memory
func (p *CurrentPlugin) ReadBytes(offset uint64) ([]byte, error) {
	length, err := p.Length(offset)
	if err != nil {
		return []byte{}, err
	}

	buffer, ok := p.Memory().Read(uint32(offset), uint32(length))
	if !ok {
		return []byte{}, fmt.Errorf("invalid memory block")
	}

	cpy := make([]byte, len(buffer))
	copy(cpy, buffer)

	return cpy, nil
}

func buildHostModule(ctx context.Context, rt wazero.Runtime, name string, funcs []HostFunction) (api.Module, error) {
	builder := rt.NewHostModuleBuilder(name)

	defineCustomHostFunctions(builder, funcs)

	return builder.Instantiate(ctx)
}

func defineCustomHostFunctions(builder wazero.HostModuleBuilder, funcs []HostFunction) {
	for _, f := range funcs {

		// Go closures capture variables by reference, not by value.
		// This means that if you directly use f inside the closure without creating
		// a separate variable (closure) and assigning the value of f to it, you might run into unexpected behavior.
		// All the closures created in the loop would end up referencing the same f, which could lead to incorrect or unintended results.
		// See: https://github.com/extism/go-sdk/issues/5#issuecomment-1666774486
		closure := f.stackCallback

		builder.NewFunctionBuilder().WithGoFunction(api.GoFunc(func(ctx context.Context, stack []uint64) {
			if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
				closure(ctx, &CurrentPlugin{plugin}, stack)
				return
			}

			panic("Invalid context, `plugin` key not found")
		}), f.Params, f.Returns).Export(f.Name)
	}
}

func instantiateEnvModule(ctx context.Context, rt wazero.Runtime) (api.Module, error) {
	builder := rt.NewHostModuleBuilder("extism:host/env")

	// A wrapper that creates allows calls from guest -> go host -> extism kernel wasm
	// See https://github.com/extism/proposals/blob/main/EIP-007-extism-runtime-kernel.md.
	extismFunc := func(name string, params []ValueType, results []ValueType) {
		builder.
			NewFunctionBuilder().
			WithGoModuleFunction(api.GoModuleFunc(func(ctx context.Context, m api.Module, stack []uint64) {
				extism, ok := ctx.Value(PluginCtxKey("extism")).(api.Module)
				if !ok {
					panic("Invalid context, `extism` key not found")
				}

				f := extism.ExportedFunction(name)
				if f == nil {
					panic(fmt.Errorf("function %q not found in extism:host", name))
				}

				err := f.CallWithStack(ctx, stack)
				if err != nil {
					panic(err)
				}
			}), params, results).
			Export(name)
	}

	extismFunc("alloc", []ValueType{ValueTypeI64}, []ValueType{ValueTypeI64})
	extismFunc("free", []ValueType{ValueTypeI64}, []ValueType{})
	extismFunc("load_u8", []ValueType{ValueTypeI64}, []ValueType{ValueTypeI32})
	extismFunc("input_load_u8", []ValueType{ValueTypeI64}, []ValueType{ValueTypeI32})
	extismFunc("store_u64", []ValueType{ValueTypeI64, ValueTypeI64}, []ValueType{})
	extismFunc("store_u8", []ValueType{ValueTypeI64, ValueTypeI32}, []ValueType{})
	extismFunc("input_set", []ValueType{ValueTypeI64, ValueTypeI64}, []ValueType{})
	extismFunc("output_set", []ValueType{ValueTypeI64, ValueTypeI64}, []ValueType{})
	extismFunc("input_length", []ValueType{}, []ValueType{ValueTypeI64})
	extismFunc("input_offset", []ValueType{}, []ValueType{ValueTypeI64})
	extismFunc("output_length", []ValueType{}, []ValueType{ValueTypeI64})
	extismFunc("output_offset", []ValueType{}, []ValueType{ValueTypeI64})
	extismFunc("length", []ValueType{ValueTypeI64}, []ValueType{ValueTypeI64})
	extismFunc("length_unsafe", []ValueType{ValueTypeI64}, []ValueType{ValueTypeI64})
	extismFunc("reset", []ValueType{}, []ValueType{})
	extismFunc("error_set", []ValueType{ValueTypeI64}, []ValueType{})
	extismFunc("error_get", []ValueType{}, []ValueType{ValueTypeI64})
	extismFunc("memory_bytes", []ValueType{}, []ValueType{ValueTypeI64})

	builder.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(api.GoModuleFunc(inputLoad_u64)), []ValueType{ValueTypeI64}, []ValueType{ValueTypeI64}).
		Export("input_load_u64")

	builder.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(load_u64), []ValueType{ValueTypeI64}, []ValueType{ValueTypeI64}).
		Export("load_u64")

	builder.NewFunctionBuilder().
		WithGoModuleFunction(api.GoModuleFunc(store_u64), []ValueType{ValueTypeI64, ValueTypeI64}, []ValueType{}).
		Export("store_u64")

	hostFunc := func(name string, f interface{}) {
		builder.NewFunctionBuilder().WithFunc(f).Export(name)
	}

	hostFunc("config_get", configGet)
	hostFunc("var_get", varGet)
	hostFunc("var_set", varSet)
	hostFunc("http_request", httpRequest)
	hostFunc("http_status_code", httpStatusCode)
	hostFunc("http_headers", httpHeaders)
	hostFunc("get_log_level", getLogLevel)

	logFunc := func(name string, level LogLevel) {
		hostFunc(name, func(ctx context.Context, m api.Module, offset uint64) {
			if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
				if LogLevel(pluginLogLevel.Load()) > level {
					plugin.currentPlugin().Free(offset)
					return
				}

				message, err := plugin.currentPlugin().ReadString(offset)
				if err != nil {
					panic(fmt.Errorf("failed to read log message from memory: %v", err))
				}

				plugin.Log(level, message)

				plugin.currentPlugin().Free(offset)

				return
			}

			panic("Invalid context, `plugin` key not found")
		})
	}

	logFunc("log_trace", LogLevelTrace)
	logFunc("log_debug", LogLevelDebug)
	logFunc("log_info", LogLevelInfo)
	logFunc("log_warn", LogLevelWarn)
	logFunc("log_error", LogLevelError)

	return builder.Instantiate(ctx)
}

func store_u64(ctx context.Context, mod api.Module, stack []uint64) {
	p, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin)
	if !ok {
		panic("Invalid context")
	}

	offset := stack[0]
	value := stack[1]
	ok = p.Memory().WriteUint64Le(uint32(offset), value)
	if !ok {
		panic(fmt.Sprintf("could not write value '%v' at offset: %v", value, offset))
	}
}

func load_u64(ctx context.Context, mod api.Module, stack []uint64) {
	p, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin)
	if !ok {
		panic("Invalid context")
	}

	stack[0], ok = p.Memory().ReadUint64Le(uint32(stack[0]))
	if !ok {
		panic(fmt.Sprintf("could not read value at offset: %v", stack[0]))
	}
}

func inputLoad_u64(ctx context.Context, mod api.Module, stack []uint64) {
	p, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin)
	if !ok {
		panic("Invalid context")
	}

	offset, ok := ctx.Value(InputOffsetKey("inputOffset")).(uint64)
	if !ok {
		panic("Invalid context")
	}

	stack[0], ok = p.Memory().ReadUint64Le(uint32(stack[0] + offset))
	if !ok {
		panic(fmt.Sprintf("could not read value at offset: %v", stack[0]))
	}
}

func configGet(ctx context.Context, m api.Module, offset uint64) uint64 {
	if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
		cp := plugin.currentPlugin()

		name, err := cp.ReadString(offset)
		if err != nil {
			panic(fmt.Errorf("failed to read config name from memory: %v", err))
		}

		value, ok := plugin.Config[name]
		if !ok {
			// Return 0 without an error if key is not found
			return 0
		}

		offset, err = cp.WriteString(value)
		if err != nil {
			panic(fmt.Errorf("failed to write config value to memory: %v", err))
		}

		return offset
	}

	panic("Invalid context, `plugin` key not found")
}

func varGet(ctx context.Context, m api.Module, offset uint64) uint64 {
	if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
		cp := plugin.currentPlugin()

		name, err := cp.ReadString(offset)
		if err != nil {
			panic(fmt.Errorf("failed to read var name from memory: %v", err))
		}

		cp.Free(offset)

		value, ok := plugin.Var[name]
		if !ok {
			// Return 0 without an error if key is not found
			return 0
		}

		offset, err = cp.WriteBytes(value)
		if err != nil {
			panic(fmt.Errorf("failed to write var value to memory: %v", err))
		}

		return offset
	}

	panic("Invalid context, `plugin` key not found")
}

func varSet(ctx context.Context, m api.Module, nameOffset uint64, valueOffset uint64) {
	plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin)
	if !ok {
		panic("Invalid context, `plugin` key not found")
	}

	if plugin.MaxVarBytes == 0 {
		panic("Vars are disabled by this host")
	}

	cp := plugin.currentPlugin()

	name, err := cp.ReadString(nameOffset)
	if err != nil {
		panic(fmt.Errorf("failed to read var name from memory: %v", err))
	}

	cp.Free(nameOffset)

	// Remove if the value offset is 0
	if valueOffset == 0 {
		delete(plugin.Var, name)
		return
	}

	value, err := cp.ReadBytes(valueOffset)
	if err != nil {
		panic(fmt.Errorf("failed to read var value from memory: %v", err))
	}

	cp.Free(valueOffset)

	// Calculate size including current key/value
	size := int(unsafe.Sizeof([]byte{})+unsafe.Sizeof("")) + len(name) + len(value)
	for k, v := range plugin.Var {
		size += len(k)
		size += len(v)
		size += int(unsafe.Sizeof([]byte{}) + unsafe.Sizeof(""))
	}

	if size >= int(plugin.MaxVarBytes) && valueOffset != 0 {
		panic("Variable store is full")
	}

	plugin.Var[name] = value
}

func httpRequest(ctx context.Context, m api.Module, requestOffset uint64, bodyOffset uint64) uint64 {
	if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
		cp := plugin.currentPlugin()

		if plugin.LastResponseHeaders != nil {
			for k := range plugin.LastResponseHeaders {
				delete(plugin.LastResponseHeaders, k)
			}
		}
		plugin.LastStatusCode = 0

		requestJson, err := cp.ReadBytes(requestOffset)
		if err != nil {
			panic(fmt.Errorf("failed to read http request from memory: %v", err))
		}

		var request HttpRequest
		err = json.Unmarshal(requestJson, &request)
		cp.Free(requestOffset)
		if err != nil {
			panic(fmt.Errorf("invalid http request: %v", err))
		}

		// default method to GET and force to be upper
		if request.Method == "" {
			request.Method = "GET"
		}
		request.Method = strings.ToUpper(request.Method)

		url, err := url.Parse(request.Url)
		if err != nil {
			panic(fmt.Errorf("invalid url: %v", err))
		}

		// deny all requests by default
		hostMatches := false
		for _, allowedHost := range plugin.AllowedHosts {
			if allowedHost == url.Hostname() {
				hostMatches = true
				break
			}

			pattern := glob.MustCompile(allowedHost)
			if pattern.Match(url.Hostname()) {
				hostMatches = true
				break
			}
		}

		if !hostMatches {
			panic(fmt.Errorf("HTTP request to '%v' is not allowed", request.Url))
		}

		var bodyReader io.Reader = nil
		if bodyOffset != 0 {
			body, err := cp.ReadBytes(bodyOffset)
			if err != nil {
				panic("failed to read response body from memory")
			}

			cp.Free(bodyOffset)

			bodyReader = bytes.NewReader(body)
		}

		req, err := http.NewRequestWithContext(ctx, request.Method, request.Url, bodyReader)
		if err != nil {
			panic(err)
		}

		for key, value := range request.Headers {
			req.Header.Set(key, value)
		}

		client := http.DefaultClient
		resp, err := client.Do(req)
		if err != nil {
			panic(err)
		}
		defer resp.Body.Close()

		if plugin.LastResponseHeaders != nil {
			for k, v := range resp.Header {
				plugin.LastResponseHeaders[strings.ToLower(k)] = strings.Join(v, ",")
			}
		}

		plugin.LastStatusCode = resp.StatusCode

		limiter := http.MaxBytesReader(nil, resp.Body, int64(plugin.MaxHttpResponseBytes))
		body, err := io.ReadAll(limiter)
		if err != nil {
			panic(err)
		}

		if len(body) == 0 {
			return 0
		} else {
			offset, err := cp.WriteBytes(body)
			if err != nil {
				panic("Failed to write resposne body to memory")
			}

			return offset
		}
	}

	panic("Invalid context, `plugin` key not found")
}

func httpStatusCode(ctx context.Context, m api.Module) int32 {
	if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
		return int32(plugin.LastStatusCode)
	}

	panic("Invalid context, `plugin` key not found")
}

func httpHeaders(ctx context.Context, _ api.Module) uint64 {
	if plugin, ok := ctx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
		if plugin.LastResponseHeaders == nil {
			return 0
		}

		data, err := json.Marshal(plugin.LastResponseHeaders)
		if err != nil {
			panic(err)
		}
		mem, err := plugin.currentPlugin().WriteBytes(data)
		if err != nil {
			panic(err)
		}
		return mem
	}

	panic("Invalid context, `plugin` key not found")
}

func getLogLevel(ctx context.Context, m api.Module) int32 {
	// if _, ok := callCtx.Value(PluginCtxKey("plugin")).(*Plugin); ok {
	// 	panic("Invalid context, `plugin` key not found")
	// }
	return LogLevel(pluginLogLevel.Load()).ExtismCompat()
}

// EncodeI32 encodes the input as a ValueTypeI32.
func EncodeI32(input int32) uint64 {
	return api.EncodeI32(input)
}

// DecodeI32 decodes the input as a ValueTypeI32.
func DecodeI32(input uint64) int32 {
	return api.DecodeI32(input)
}

// EncodeU32 encodes the input as a ValueTypeI32.
func EncodeU32(input uint32) uint64 {
	return api.EncodeU32(input)
}

// DecodeU32 decodes the input as a ValueTypeI32.
func DecodeU32(input uint64) uint32 {
	return api.DecodeU32(input)
}

// EncodeI64 encodes the input as a ValueTypeI64.
func EncodeI64(input int64) uint64 {
	return api.EncodeI64(input)
}

// EncodeF32 encodes the input as a ValueTypeF32.
//
// See DecodeF32
func EncodeF32(input float32) uint64 {
	return api.EncodeF32(input)
}

// DecodeF32 decodes the input as a ValueTypeF32.
//
// See EncodeF32
func DecodeF32(input uint64) float32 {
	return api.DecodeF32(input)
}

// EncodeF64 encodes the input as a ValueTypeF64.
//
// See EncodeF32
func EncodeF64(input float64) uint64 {
	return api.EncodeF64(input)
}

// DecodeF64 decodes the input as a ValueTypeF64.
//
// See EncodeF64
func DecodeF64(input uint64) float64 {
	return api.DecodeF64(input)
}


================================================
File: module.go
================================================
package extism

import "github.com/tetratelabs/wazero/api"

// Module is a wrapper around a wazero module. It allows us to provide
// our own API and stability guarantees despite any changes that wazero
// may choose to make.
type Module struct {
	inner api.Module
}

// ExportedFunctions returns a map of functions exported from the module
// keyed by the function name.
func (m *Module) ExportedFunctions() map[string]FunctionDefinition {
	v := make(map[string]FunctionDefinition)
	for name, def := range m.inner.ExportedFunctionDefinitions() {
		v[name] = FunctionDefinition{inner: def}
	}
	return v
}

// FunctionDefinition represents a function defined in a module. It provides
// a wrapper around the underlying wazero function definition.
type FunctionDefinition struct {
	inner api.FunctionDefinition
}

func (f *FunctionDefinition) Name() string {
	return f.inner.Name()
}


================================================
File: plugin.go
================================================
// new
package extism

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strings"
	"sync/atomic"
	"time"

	observe "github.com/dylibso/observe-sdk/go"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
)

type CompiledPlugin struct {
	runtime wazero.Runtime
	main    wazero.CompiledModule
	extism  wazero.CompiledModule
	env     api.Module
	modules map[string]wazero.CompiledModule

	// when a module (main) is instantiated, it may have a module name that's added
	// to the data section of the wasm. If this is the case, we won't be able to
	// instantiate that module more than once. This counter acts as the module name
	// incrementing each time we instantiate the module.
	instanceCount atomic.Uint64

	// this is the raw wasm bytes of the provided module, it is required when using a tracing observeAdapter.
	// If an adapter is not provided, this field will be nil.
	wasmBytes      []byte
	hasWasi        bool
	manifest       Manifest
	observeAdapter *observe.AdapterBase
	observeOptions *observe.Options

	maxHttp                   int64
	maxVar                    int64
	enableHttpResponseHeaders bool
}

type PluginConfig struct {
	RuntimeConfig             wazero.RuntimeConfig
	EnableWasi                bool
	ObserveAdapter            *observe.AdapterBase
	ObserveOptions            *observe.Options
	EnableHttpResponseHeaders bool

	// ModuleConfig is only used when a plugins are built using the NewPlugin
	// function. In this function, the plugin is both compiled, and an instance
	// of the plugin is instantiated, and the ModuleConfig is passed to the
	// instance.
	//
	// When plugins are built using NewCompiledPlugin, the ModuleConfig has no
	// effect because the instance is not created. Instead, the ModuleConfig is
	// passed directly in calls to the CompiledPlugin.Instance method.
	//
	// NOTE: Module name and start functions are ignored as they are overridden by Extism, also if Manifest contains
	// non-empty AllowedPaths, then FS is also ignored. If EXTISM_ENABLE_WASI_OUTPUT is set, then stdout and stderr are
	// set to os.Stdout and os.Stderr respectively (ignoring user defined module config).
	ModuleConfig wazero.ModuleConfig
}

// NewPlugin creates compiles and instantiates a plugin that is ready
// to be used. Plugins are not thread-safe. If you need to use a plugin
// across multiple goroutines, use NewCompiledPlugin and create instances
// of the plugin using the CompiledPlugin.Instance method.
func NewPlugin(
	ctx context.Context,
	manifest Manifest,
	config PluginConfig,
	functions []HostFunction,
) (*Plugin, error) {
	c, err := NewCompiledPlugin(ctx, manifest, config, functions)
	if err != nil {
		return nil, err
	}
	p, err := c.Instance(ctx, PluginInstanceConfig{
		ModuleConfig: config.ModuleConfig,
	})
	if err != nil {
		return nil, err
	}
	p.close = append(p.close, c.Close)
	return p, nil
}

func calculateMaxHttp(manifest Manifest) int64 {
	// Default is 50MB
	maxHttp := int64(1024 * 1024 * 50)
	if manifest.Memory != nil && manifest.Memory.MaxHttpResponseBytes >= 0 {
		maxHttp = manifest.Memory.MaxHttpResponseBytes
	}
	return maxHttp
}

func calculateMaxVar(manifest Manifest) int64 {
	// Default is 1MB
	maxVar := int64(1024 * 1024)
	if manifest.Memory != nil && manifest.Memory.MaxVarBytes >= 0 {
		maxVar = manifest.Memory.MaxVarBytes
	}
	return maxVar
}

// NewCompiledPlugin creates a compiled plugin that is ready to be instantiated.
// You can instantiate the plugin multiple times using the CompiledPlugin.Instance
// method and run those instances concurrently.
func NewCompiledPlugin(
	ctx context.Context,
	manifest Manifest,
	config PluginConfig,
	funcs []HostFunction,
) (*CompiledPlugin, error) {
	count := len(manifest.Wasm)
	if count == 0 {
		return nil, fmt.Errorf("manifest can't be empty")
	}

	runtimeConfig := config.RuntimeConfig
	if runtimeConfig == nil {
		runtimeConfig = wazero.NewRuntimeConfig()
	}

	// Make sure function calls are cancelled if the context is cancelled
	if manifest.Timeout > 0 {
		runtimeConfig = runtimeConfig.WithCloseOnContextDone(true)
	}

	if manifest.Memory != nil {
		if manifest.Memory.MaxPages > 0 {
			runtimeConfig = runtimeConfig.WithMemoryLimitPages(manifest.Memory.MaxPages)
		}
	}

	p := CompiledPlugin{
		manifest:                  manifest,
		runtime:                   wazero.NewRuntimeWithConfig(ctx, runtimeConfig),
		observeAdapter:            config.ObserveAdapter,
		observeOptions:            config.ObserveOptions,
		enableHttpResponseHeaders: config.EnableHttpResponseHeaders,
		modules:                   make(map[string]wazero.CompiledModule),
		maxHttp:                   calculateMaxHttp(manifest),
		maxVar:                    calculateMaxVar(manifest),
	}

	if config.EnableWasi {
		wasi_snapshot_preview1.MustInstantiate(ctx, p.runtime)
		p.hasWasi = true
	}

	// Build host modules
	hostModules := make(map[string][]HostFunction)
	for _, f := range funcs {
		hostModules[f.Namespace] = append(hostModules[f.Namespace], f)
	}
	for name, funcs := range hostModules {
		_, err := buildHostModule(ctx, p.runtime, name, funcs)
		if err != nil {
			return nil, fmt.Errorf("building host module: %w", err)
		}
	}

	// Compile the extism module
	var err error
	p.extism, err = p.runtime.CompileModule(ctx, extismRuntimeWasm)
	if err != nil {
		return nil, fmt.Errorf("instantiating extism module: %w", err)
	}

	// Build and instantiate extism:host/env module
	p.env, err = instantiateEnvModule(ctx, p.runtime)
	if err != nil {
		return nil, err
	}

	// Try to find the main module:
	//  - There is always one main module
	//  - If a Wasm value has the Name field set to "main" then use that module
	//  - If there is only one module in the manifest then that is the main module by default
	//  - Otherwise the last module listed is the main module

	foundMain := false
	for i, wasm := range manifest.Wasm {
		data, err := wasm.ToWasmData(ctx)
		if err != nil {
			return nil, err
		}

		if (data.Name == "" || i == len(manifest.Wasm)-1) && !foundMain {
			data.Name = "main"
		}

		_, okm := p.modules[data.Name]

		if data.Name == "extism:host/env" || okm {
			return nil, fmt.Errorf("module name collision: '%s'", data.Name)
		}

		if data.Hash != "" {
			calculatedHash := calculateHash(data.Data)
			if data.Hash != calculatedHash {
				return nil, fmt.Errorf("hash mismatch for module '%s'", data.Name)
			}
		}

		if p.observeAdapter != nil {
			p.wasmBytes = data.Data
		}

		compiledModule, err := p.runtime.CompileModule(ctx, data.Data)
		if err != nil {
			return nil, err
		}

		if data.Name == "main" {
			if foundMain {
				return nil, errors.New("can't have more than one main module")
			}
			p.main = compiledModule
			foundMain = true
		} else {
			// Store compiled module for instantiation
			p.modules[data.Name] = compiledModule
			// Create wrapper with original name that will forward calls to the actual module instance. See createModuleWrapper for more details.
			_, err = createModuleWrapper(ctx, p.runtime, data.Name, compiledModule)
			if err != nil {
				return nil, fmt.Errorf("failed to create wrapper for %s: %w", data.Name, err)
			}
		}
	}

	if p.main == nil {
		return nil, errors.New("no main module found")
	}

	// We no longer need the wasm in the manifest so nil it
	// to make the slice eligible for garbage collection.
	p.manifest.Wasm = nil

	return &p, nil
}

// createModuleWrapper creates a host module that acts as a proxy for module instances.
// In Wazero, modules with the same name cannot be instantiated multiple times in the same runtime.
// However, we need each Plugin instance to have its own copy of each module for isolation. To solve this, we:
//  1. Create a host module wrapper that keeps the original module name (needed for imports to work)
//  2. Instantiate actual module copies with unique names for each Plugin
//  3. The wrapper forwards function calls to the correct module instance for each Plugin
func createModuleWrapper(ctx context.Context, rt wazero.Runtime, name string, compiled wazero.CompiledModule) (api.Module, error) {
	builder := rt.NewHostModuleBuilder(name)

	// Create proxy functions for each exported function from the original module.
	// These proxies will forward calls to the appropriate module instance.
	for _, export := range compiled.ExportedFunctions() {
		exportName := export.Name()

		// Skip wrapping the _start function since it's automatically called by wazero during instantiation.
		// The wrapper functions require a Plugin instance in the context to work, but during wrapper
		// instantiation there is no Plugin instance yet.
		if exportName == "_start" {
			continue
		}

		// Create a proxy function that:
		// 1. Gets the calling Plugin instance from context
		// 2. Looks up that Plugin's copy of this module
		// 3. Forwards the call to the actual function
		wrapper := func(callCtx context.Context, mod api.Module, stack []uint64) {
			// Get the Plugin instance that's making this call
			plugin, ok := callCtx.Value(PluginCtxKey("plugin")).(*Plugin)
			if !ok {
				panic("Invalid context, `plugin` key not found")
			}

			// Get this Plugin's instance of the module
			actualModule, ok := plugin.modules[name]
			if !ok {
				panic(fmt.Sprintf("module %s not found in plugin", name))
			}

			// Forward the call to the actual module instance
			fn := actualModule.ExportedFunction(exportName)
			if fn == nil {
				panic(fmt.Sprintf("function %s not found in module %s", exportName, name))
			}

			err := fn.CallWithStack(callCtx, stack)
			if err != nil {
				panic(err)
			}
		}

		// Export the proxy function with the same name and signature as the original
		builder.NewFunctionBuilder().
			WithGoModuleFunction(api.GoModuleFunc(wrapper), export.ParamTypes(), export.ResultTypes()).
			Export(exportName)
	}

	return builder.Instantiate(ctx)
}

func (p *CompiledPlugin) Close(ctx context.Context) error {
	return p.runtime.Close(ctx)
}

func (p *CompiledPlugin) Instance(ctx context.Context, config PluginInstanceConfig) (*Plugin, error) {
	instanceNum := p.instanceCount.Add(1)

	var closers []func(ctx context.Context) error

	moduleConfig := config.ModuleConfig
	if moduleConfig == nil {
		moduleConfig = wazero.NewModuleConfig()
	}

	// NOTE: we don't want wazero to call the start function, we will initialize
	// the guest runtime manually.
	// See: https://github.com/extism/go-sdk/pull/1#issuecomment-1650527495
	moduleConfig = moduleConfig.WithStartFunctions()

	if len(p.manifest.AllowedPaths) > 0 {
		// NOTE: this is only necessary for guest modules because
		// host modules have the same access privileges as the host itself
		fs := wazero.NewFSConfig()
		for host, guest := range p.manifest.AllowedPaths {
			if strings.HasPrefix(host, "ro:") {
				trimmed := strings.TrimPrefix(host, "ro:")
				fs = fs.WithReadOnlyDirMount(trimmed, guest)
			} else {
				fs = fs.WithDirMount(host, guest)
			}
		}
		moduleConfig = moduleConfig.WithFSConfig(fs)
	}

	_, wasiOutput := os.LookupEnv("EXTISM_ENABLE_WASI_OUTPUT")
	if p.hasWasi && wasiOutput {
		moduleConfig = moduleConfig.WithStderr(os.Stderr).WithStdout(os.Stdout)
	}

	var trace *observe.TraceCtx
	var err error
	if p.observeAdapter != nil {
		trace, err = p.observeAdapter.NewTraceCtx(ctx, p.runtime, p.wasmBytes, p.observeOptions)
		if err != nil {
			return nil, fmt.Errorf("failed to initialize Observe Adapter: %v", err)
		}
	}

	// Compile and instantiate the extism runtime. This runtime is stateful and needs to be
	// instantiated on a per-instance basis. We don't provide a name because the module needs
	// to be anonymous -- you cannot instantiate multiple modules with the same name into the
	// same runtime. It is okay that this is anonymous, because this module is only called
	// from Go host functions and not from the Wasm module itself.
	extism, err := p.runtime.InstantiateModule(ctx, p.extism, wazero.NewModuleConfig())
	if err != nil {
		return nil, fmt.Errorf("instantiating extism module: %w", err)
	}

	closers = append(closers, extism.Close)

	// Instantiate all non-main modules first
	instancedModules := make(map[string]api.Module)
	for name, compiledModule := range p.modules {
		uniqueName := fmt.Sprintf("%s_%d", name, instanceNum)
		instance, err := p.runtime.InstantiateModule(ctx, compiledModule, moduleConfig.WithName(uniqueName))
		if err != nil {
			for _, closer := range closers {
				closer(ctx)
			}
			return nil, fmt.Errorf("instantiating module %s: %w", name, err)
		}
		instancedModules[name] = instance
		closers = append(closers, instance.Close)
	}

	mainModuleName := fmt.Sprintf("main_%d", instanceNum)
	main, err := p.runtime.InstantiateModule(ctx, p.main, moduleConfig.WithName(mainModuleName))
	if err != nil {
		for _, closer := range closers {
			closer(ctx)
		}

		return nil, fmt.Errorf("instantiating module: %w", err)
	}

	closers = append(closers, main.Close)

	var headers map[string]string = nil
	if p.enableHttpResponseHeaders {
		headers = map[string]string{}
	}

	instance := &Plugin{
		close:                closers,
		extism:               extism,
		hasWasi:              p.hasWasi,
		mainModule:           main,
		modules:              instancedModules,
		Timeout:              time.Duration(p.manifest.Timeout) * time.Millisecond,
		Config:               p.manifest.Config,
		Var:                  make(map[string][]byte),
		AllowedHosts:         p.manifest.AllowedHosts,
		AllowedPaths:         p.manifest.AllowedPaths,
		LastStatusCode:       0,
		LastResponseHeaders:  headers,
		MaxHttpResponseBytes: p.maxHttp,
		MaxVarBytes:          p.maxVar,
		guestRuntime:         guestRuntime{},
		Adapter:              p.observeAdapter,
		log:                  logStd,
		traceCtx:             trace,
	}
	instance.guestRuntime = detectGuestRuntime(instance)

	return instance, nil
}


================================================
File: runtime.go
================================================
package extism

import (
	"context"

	"github.com/tetratelabs/wazero/api"
)

// TODO: test runtime initialization for WASI and Haskell

type runtimeType uint8

const (
	None runtimeType = iota
	Haskell
	Wasi
)

type guestRuntime struct {
	mainRuntime moduleRuntime
	runtimes    map[string]moduleRuntime
	init        func(ctx context.Context) error
	initialized bool
}

type moduleRuntime struct {
	runtimeType runtimeType
	init        func(ctx context.Context) error
	initialized bool
}

// detectGuestRuntime detects the runtime of the main module and all other modules
// it returns a guest runtime with an initialization function specific that invokes
// the initialization function of all the modules, with the main module last.
func detectGuestRuntime(p *Plugin) guestRuntime {
	r := guestRuntime{runtimes: make(map[string]moduleRuntime)}

	r.mainRuntime = detectModuleRuntime(p, p.mainModule)
	for k, m := range p.modules {
		r.runtimes[k] = detectModuleRuntime(p, m)
	}

	r.init = func(ctx context.Context) error {

		for k, v := range r.runtimes {
			p.Logf(LogLevelDebug, "Initializing runtime for module %v", k)
			err := v.init(ctx)
			if err != nil {
				return err
			}
			v.initialized = true
		}

		m := r.mainRuntime
		p.Logf(LogLevelDebug, "Initializing runtime for main module")
		err := m.init(ctx)
		if err != nil {
			return err
		}
		m.initialized = true

		return nil
	}

	return r
}

// detectModuleRuntime detects the specific runtime of a given module
// it returns a module runtime with an initialization function specific to that module
func detectModuleRuntime(p *Plugin, m api.Module) moduleRuntime {
	runtime, ok := haskellRuntime(p, m)
	if ok {
		return runtime
	}

	runtime, ok = wasiRuntime(p, m)
	if ok {
		return runtime
	}

	p.Log(LogLevelTrace, "No runtime detected")
	return moduleRuntime{runtimeType: None, init: func(_ context.Context) error { return nil }, initialized: true}
}

// Check for Haskell runtime initialization functions
// Initialize Haskell runtime if `hs_init` and `hs_exit` are present,
// by calling the `hs_init` export
func haskellRuntime(p *Plugin, m api.Module) (moduleRuntime, bool) {
	initFunc := m.ExportedFunction("hs_init")
	if initFunc == nil {
		return moduleRuntime{}, false
	}

	params := initFunc.Definition().ParamTypes()

	if len(params) != 2 || params[0] != api.ValueTypeI32 || params[1] != api.ValueTypeI32 {
		p.Logf(LogLevelTrace, "hs_init function found with type %v", params)
	}

	reactorInit := m.ExportedFunction("_initialize")

	init := func(ctx context.Context) error {
		if reactorInit != nil {
			_, err := reactorInit.Call(ctx)
			if err != nil {
				p.Logf(LogLevelError, "Error running reactor _initialize: %s", err.Error())
			}
		}
		_, err := initFunc.Call(ctx, 0, 0)
		if err == nil {
			p.Log(LogLevelDebug, "Initialized Haskell language runtime.")
		}

		return err
	}

	p.Log(LogLevelTrace, "Haskell runtime detected")
	return moduleRuntime{runtimeType: Haskell, init: init}, true
}

// Check for initialization functions defined by the WASI standard
func wasiRuntime(p *Plugin, m api.Module) (moduleRuntime, bool) {
	if !p.hasWasi {
		return moduleRuntime{}, false
	}

	// WASI supports two modules: Reactors and Commands
	// we prioritize Reactors over Commands
	// see: https://github.com/WebAssembly/WASI/blob/main/legacy/application-abi.md
	if r, ok := reactorModule(m, p); ok {
		return r, ok
	}

	return commandModule(m, p)
}

// Check for `_initialize` this is used by WASI to initialize certain interfaces.
func reactorModule(m api.Module, p *Plugin) (moduleRuntime, bool) {
	init := findFunc(m, p, "_initialize")
	if init == nil {
		return moduleRuntime{}, false
	}

	p.Logf(LogLevelTrace, "WASI runtime detected")
	p.Logf(LogLevelTrace, "Reactor module detected")

	return moduleRuntime{runtimeType: Wasi, init: init}, true
}

// Check for `__wasm__call_ctors`, this is used by WASI to
// initialize certain interfaces.
func commandModule(m api.Module, p *Plugin) (moduleRuntime, bool) {
	init := findFunc(m, p, "__wasm_call_ctors")
	if init == nil {
		return moduleRuntime{}, false
	}

	p.Logf(LogLevelTrace, "WASI runtime detected")
	p.Logf(LogLevelTrace, "Command module detected")

	return moduleRuntime{runtimeType: Wasi, init: init}, true
}

func findFunc(m api.Module, p *Plugin, name string) func(context.Context) error {
	initFunc := m.ExportedFunction(name)
	if initFunc == nil {
		return nil
	}

	params := initFunc.Definition().ParamTypes()
	if len(params) != 0 {
		p.Logf(LogLevelTrace, "%v function found with type %v", name, params)
		return nil
	}

	return func(ctx context.Context) error {
		p.Logf(LogLevelDebug, "Calling %v", name)
		_, err := initFunc.Call(ctx)
		return err
	}
}

func equal(actual []byte, expected []byte) bool {
	if len(actual) != len(expected) {
		return false
	}

	for i, k := range actual {
		if expected[i] != k {
			return false
		}
	}

	return true
}


================================================
File: plugins/config/main.go
================================================
package main

import "github.com/extism/go-pdk"

//export run_test
func run_test() int32 {
	thing, ok := pdk.GetConfig("thing")

	if !ok {
		thing = "<unset by host>"
	}

	output := `{"config": "` + thing + `"}`
	mem := pdk.AllocateString(output)

	// zero-copy output to host
	pdk.OutputMemory(mem)

	return 0
}

func main() {}


================================================
File: plugins/exit/main.go
================================================
package main

import (
	"os"
	"strconv"

	"github.com/extism/go-pdk"
)

func main() {
	if config, ok := pdk.GetConfig("code"); ok {
		if code, err := strconv.Atoi(config); err == nil {
			os.Exit(code)
		} else {
			os.Exit(1)
		}
	} else {
		os.Exit(2)
	}
}


================================================
File: plugins/fs/main.go
================================================
package main

import (
	"os"

	"github.com/extism/go-pdk"
)

//export __wasm_call_ctors
func __wasm_call_ctors()

//export _initialize
func _initialize() {
	__wasm_call_ctors()
}

//export run_test
func run_test() int32 {
	content, err := updateFile("/mnt/test.txt")
	if err != nil {
		pdk.Log(pdk.LogError, err.Error())
		return 1
	} else {
		mem := pdk.AllocateBytes(content)
		// zero-copy output to host
		pdk.OutputMemory(mem)
	}

	return 0
}

func updateFile(filename string) ([]byte, error) {
	// Read the file and get its contents as a byte slice
	content, err := os.ReadFile(filename)
	if err != nil {
		return []byte{}, err
	}

	// Write to the file, just to prove that we can
	err = os.WriteFile(filename, []byte(content), 0644)
	if err != nil {
		return []byte{}, err
	}

	return content, nil
}

func main() {}


================================================
File: plugins/host/main.go
================================================
package main

import (
	"fmt"

	"github.com/extism/go-pdk"
)

//go:wasm-module extism:host/user
//export mult
func mult(x, y uint64) uint64

//export run_test
func run_test() int32 {
	r := mult(42, 2)

	output := fmt.Sprintf("42 x 2 = %v", r)
	mem := pdk.AllocateString(output)

	// zero-copy output to host
	pdk.OutputMemory(mem)

	return 0
}

func main() {}


================================================
File: plugins/host_memory/main.go
================================================
package main

import (
	"fmt"

	"github.com/extism/go-pdk"
)

//go:wasm-module host
//export to_upper
func to_upper(offset uint64) uint64

//export run_test
func run_test() int32 {
	name := pdk.InputString()

	// Store the message in the wasm memory and get an pointer for the location
	message := fmt.Sprintf("Hello %s!", name)
	mem := pdk.AllocateString(message)

	pdk.Log(pdk.LogError, fmt.Sprintf("offset: %v, length: %v", mem.Offset(), mem.Length()))

	// Send the pointer of the message to to_upper and get back
	// a new pointer for the new transformed message
	offset := to_upper(mem.Offset())
	mem = pdk.FindMemory(offset)

	pdk.Log(pdk.LogError, fmt.Sprintf("offset: %v, length: %v", offset, mem.Length()))

	// zero-copy output to host
	pdk.OutputMemory(mem)

	return 0
}

func main() {}


================================================
File: plugins/host_multiple/main.go
================================================
package main

import (
	"github.com/extism/go-pdk"
)

//go:wasm-module extism:host/user
//export hostPurpleMessage
func hostPurpleMessage(offset uint64) uint64

func purpleMessage(message string) pdk.Memory {
	messageMemory := pdk.AllocateString(message)
	off := hostPurpleMessage(messageMemory.Offset())
	return pdk.FindMemory(off)
}

//go:wasm-module extism:host/user
//export hostGreenMessage
func hostGreenMessage(offset uint64) uint64

func greenMessage(message string) pdk.Memory {
	messageMemory := pdk.AllocateString(message)
	off := hostGreenMessage(messageMemory.Offset())
	return pdk.FindMemory(off)
}

//go:wasm-module extism:host/user
//export say_purple
func say_purple() int32 {
	input := pdk.InputString()
	output := "👋 Hello from say_purple " + input

	mem := purpleMessage(output)

	pdk.OutputMemory(mem)
	return 0

}

//go:wasm-module extism:host/user
//export say_green
func say_green() int32 {
	input := pdk.Input()
	output := "🫱 Hey from say_green " + string(input)

	mem := greenMessage(output)

	pdk.OutputMemory(mem)
	return 0

}
func main() {}


================================================
File: plugins/http/main.go
================================================
package main

import (
	"github.com/extism/go-pdk"
)

//export run_test
func run_test() int32 {
	// create an HTTP Request (without relying on WASI), set headers as needed
	req := pdk.NewHTTPRequest("GET", "https://jsonplaceholder.typicode.com/todos/1")
	req.SetHeader("some-name", "some-value")
	req.SetHeader("another", "again")
	// send the request, get response back (can check status on response via res.Status())
	res := req.Send()

	// zero-copy output to host
	pdk.OutputMemory(res.Memory())

	return 0
}

func main() {}


================================================
File: plugins/lib/main.go
================================================
package main

import (
	"strings"

	pdk "github.com/extism/go-pdk"
)

//go:export capitalize
func Capitalize(ptr uint64) uint64 {
	mem := pdk.FindMemory(ptr)
	bytes := mem.ReadBytes()
	capitalized := strings.ToUpper(string(bytes))
	out := pdk.AllocateString(capitalized)
	return out.Offset()
}

func main() {}


================================================
File: plugins/log/main.go
================================================
package main

import (
	"fmt"

	pdk "github.com/extism/go-pdk"
)

//export run_test
func run_test() int32 {
	pdk.Log(pdk.LogTrace, "this is a trace log")
	pdk.Log(pdk.LogDebug, "this is a debug log")
	pdk.Log(pdk.LogInfo, "this is an info log")
	pdk.Log(pdk.LogWarn, "this is a warning log")
	pdk.Log(pdk.LogError, "this is an error log")

	return 0
}

func getU32(name string) (uint32, bool) {
	bytes := pdk.GetVar(name)
	if bytes == nil {
		return 0, false
	} else if len(bytes) != 4 {
		panic(fmt.Sprintf("Expected a byte slice of length 4 but got %d", len(bytes)))
	}

	var array [4]byte
	for i := 0; i < 4; i++ {
		array[i] = bytes[i]
	}

	return uintFromLEBytes(array), true
}

func setU32(name string, value uint32) {
	pdk.SetVar(name, uintToLEBytes(value))
}

func uintFromLEBytes(bytes [4]byte) uint32 {
	return uint32(bytes[0]) | uint32(bytes[1])<<8 | uint32(bytes[2])<<16 | uint32(bytes[3])<<24
}

func uintToLEBytes(num uint32) []byte {
	var bytes [4]byte
	bytes[0] = byte(num)
	bytes[1] = byte(num >> 8)
	bytes[2] = byte(num >> 16)
	bytes[3] = byte(num >> 24)
	return bytes[:]
}

func main() {}


================================================
File: plugins/main/main.go
================================================
package main

import (
	"github.com/extism/go-pdk"
)

//go:wasm-module lib
//export capitalize
func Capitalize(offset uint64) uint64

//go:export run_test
func run_test() int32 {
	name := pdk.InputString()

	ptr := pdk.AllocateString(name)
	capitalizedPtr := Capitalize(ptr.Offset())
	capitalizedMem := pdk.FindMemory(capitalizedPtr)
	capitalized := string(capitalizedMem.ReadBytes())

	pdk.OutputString("Hello, " + capitalized)
	return 0
}

func main() {}


================================================
File: plugins/noop/main.go
================================================
package main

import "github.com/extism/go-pdk"

//export run_test
func run_test() int32 {
	pdk.SetErrorString("my custom error")
	return 1
}

func main() {}


================================================
File: plugins/println/main.go
================================================
package main

import (
	"fmt"

	pdk "github.com/extism/go-pdk"
)

//export run_test
func run_test() int32 {
	input := pdk.InputString()
	fmt.Println("this was printed from the plugin", input)
	return 0
}

func main() {}


================================================
File: plugins/replace/main.go
================================================
package main

import (
	"strings"

	"github.com/extism/go-pdk"
)

//export run_test
func run_test() int32 {
	input := pdk.InputString()

	output := strings.ReplaceAll(input, "test", "wasm")
	mem := pdk.AllocateString(output)

	// zero-copy output to host
	pdk.OutputMemory(mem)

	return 0
}

func main() {}


================================================
File: plugins/sleep/main.go
================================================
package main

import (
	"fmt"
	"strconv"
	"time"

	"github.com/extism/go-pdk"
)

//export run_test
func run_test() int32 {
	config, _ := pdk.GetConfig("duration")
	seconds, _ := strconv.Atoi(config)

	duration := time.Duration(seconds) * time.Second
	now := time.Now()

	// time.Sleep() doesn't work here
	for time.Now().Before(now.Add(duration)) {
		// busy loop
	}

	mem := pdk.AllocateString(fmt.Sprintf("slept for %v seconds", seconds))

	// zero-copy output to host
	pdk.OutputMemory(mem)

	return 0
}

func main() {}


================================================
File: plugins/var/main.go
================================================
package main

import (
	"fmt"

	"github.com/extism/go-pdk"
)

//export run_test
func run_test() int32 {
	a, ok := getU32("a")

	if !ok {
		a = 0
	}

	setU32("a", a*2)

	output := fmt.Sprintf("a: %v", a)
	mem := pdk.AllocateString(output)

	// zero-copy output to host
	pdk.OutputMemory(mem)

	return 0
}

func getU32(name string) (uint32, bool) {
	bytes := pdk.GetVar(name)
	if bytes == nil {
		return 0, false
	} else if len(bytes) != 4 {
		panic(fmt.Sprintf("Expected a byte slice of length 4 but got %d", len(bytes)))
	}

	var array [4]byte
	for i := 0; i < 4; i++ {
		array[i] = bytes[i]
	}

	return uintFromLEBytes(array), true
}

func setU32(name string, value uint32) {
	pdk.SetVar(name, uintToLEBytes(value))
}

func uintFromLEBytes(bytes [4]byte) uint32 {
	return uint32(bytes[0]) | uint32(bytes[1])<<8 | uint32(bytes[2])<<16 | uint32(bytes[3])<<24
}

func uintToLEBytes(num uint32) []byte {
	var bytes [4]byte
	bytes[0] = byte(num)
	bytes[1] = byte(num >> 8)
	bytes[2] = byte(num >> 16)
	bytes[3] = byte(num >> 24)
	return bytes[:]
}

func main() {}


